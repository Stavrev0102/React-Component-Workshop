import "./chunk-UXIASGQL.js";

// ../node_modules/uil/build/uil.module.js
var t = "4.3.0";
var s = { ui: [], dom: null, ID: null, lock: false, wlock: false, current: -1, needReZone: true, needResize: false, forceZone: false, isEventsInit: false, isLeave: false, downTime: 0, prevTime: 0, prevDefault: ["contextmenu"], pointerEvent: ["pointerdown", "pointermove", "pointerup"], eventOut: ["pointercancel", "pointerout", "pointerleave"], xmlserializer: null, tmpTime: null, tmpImage: null, oldCursor: "auto", input: null, parent: null, firstImput: true, hiddenImput: null, hiddenSizer: null, hasFocus: false, startInput: false, inputRange: [0, 0], cursorId: 0, str: "", pos: 0, startX: -1, moveX: -1, debugInput: false, isLoop: false, listens: [], e: { type: null, clientX: 0, clientY: 0, keyCode: NaN, key: null, delta: 0 }, isMobile: false, now: null, getTime: function() {
  return self.performance && self.performance.now ? self.performance.now.bind(performance) : Date.now;
}, add: function(t2) {
  s.ui.push(t2), s.getZone(t2), s.isEventsInit || s.initEvents();
}, testMobile: function() {
  let t2 = navigator.userAgent;
  return !!(t2.match(/Android/i) || t2.match(/webOS/i) || t2.match(/iPhone/i) || t2.match(/iPad/i) || t2.match(/iPod/i) || t2.match(/BlackBerry/i) || t2.match(/Windows Phone/i));
}, remove: function(t2) {
  let i2 = s.ui.indexOf(t2);
  -1 !== i2 && (s.removeListen(t2), s.ui.splice(i2, 1)), 0 === s.ui.length && s.removeEvents();
}, initEvents: function() {
  if (s.isEventsInit)
    return;
  let t2 = document.body;
  s.isMobile = s.testMobile(), s.now = s.getTime(), s.isMobile ? t2.style.touchAction = "none" : t2.addEventListener("wheel", s, { passive: false }), t2.addEventListener("pointercancel", s), t2.addEventListener("pointerleave", s), t2.addEventListener("pointermove", s), t2.addEventListener("pointerdown", s), t2.addEventListener("pointerup", s), t2.addEventListener("keydown", s, false), t2.addEventListener("keyup", s, false), window.addEventListener("resize", s.resize, false), s.isEventsInit = true, s.dom = t2;
}, removeEvents: function() {
  if (!s.isEventsInit)
    return;
  let t2 = document.body;
  s.isMobile || t2.removeEventListener("wheel", s), t2.removeEventListener("pointercancel", s), t2.removeEventListener("pointerleave", s), t2.removeEventListener("pointermove", s), t2.removeEventListener("pointerdown", s), t2.removeEventListener("pointerup", s), t2.removeEventListener("keydown", s), t2.removeEventListener("keyup", s), window.removeEventListener("resize", s.resize), s.isEventsInit = false;
}, resize: function() {
  let t2, i2 = s.ui.length;
  for (; i2--; )
    t2 = s.ui[i2], t2.isGui && !t2.isCanvasOnly && t2.autoResize && t2.calc();
  s.needReZone = true, s.needResize = false;
}, out: function() {
  console.log("im am out"), s.clearOldID();
}, in: function() {
  console.log("im am in");
}, fakeUp: function() {
  this.handleEvent({ type: "pointerup" });
}, handleEvent: function(t2) {
  -1 !== s.prevDefault.indexOf(t2.type) && t2.preventDefault(), s.needResize && s.resize(), s.findZone(s.forceZone);
  let i2 = s.e, e2 = false;
  "keydown" === t2.type && s.keydown(t2), "keyup" === t2.type && s.keyup(t2), "wheel" === t2.type ? i2.delta = t2.deltaY > 0 ? 1 : -1 : i2.delta = 0;
  let h2 = t2.pointerType;
  if (i2.clientX = ("touch" === h2 ? t2.pageX : t2.clientX) || 0, i2.clientY = ("touch" === h2 ? t2.pageY : t2.clientY) || 0, i2.type = t2.type, -1 !== s.eventOut.indexOf(t2.type) && (e2 = true, i2.type = "mouseup"), "pointerleave" === t2.type && (s.isLeave = true), "pointerdown" === t2.type && (i2.type = "mousedown"), "pointerup" === t2.type && (i2.type = "mouseup"), "pointermove" === t2.type && (s.isLeave && (s.isLeave = false, s.resize()), i2.type = "mousemove"), "mousedown" === i2.type) {
    if (s.downTime = s.now(), s.downTime - s.prevTime < 200)
      return s.selectAll(), false;
    s.prevTime = s.downTime, s.forceZone = false;
  }
  "mousedown" === i2.type && s.clearInput(), "mousedown" === i2.type && (s.lock = true), "mouseup" === i2.type && (s.lock = false), s.isMobile && "mousedown" === i2.type && s.findID(i2), "mousemove" !== i2.type || s.lock || s.findID(i2), null !== s.ID && (s.ID.isCanvasOnly && (i2.clientX = s.ID.mouse.x, i2.clientY = s.ID.mouse.y), s.ID.handleEvent(i2)), s.isMobile && "mouseup" === i2.type && s.clearOldID(), e2 && s.clearOldID();
}, findID: function(t2) {
  let i2, e2, h2, o2 = s.ui.length, n2 = -1;
  for (; o2--; )
    if (i2 = s.ui[o2], i2.isCanvasOnly ? (e2 = i2.mouse.x, h2 = i2.mouse.y) : (e2 = t2.clientX, h2 = t2.clientY), s.onZone(i2, e2, h2)) {
      n2 = o2, n2 !== s.current && (s.clearOldID(), s.current = n2, s.ID = i2);
      break;
    }
  -1 === n2 && s.clearOldID();
}, clearOldID: function() {
  s.ID && (s.current = -1, s.ID.reset(), s.ID = null, s.cursor());
}, calcUis: (t2, i2, e2, h2 = false) => {
  let o2, n2, r2, l2 = t2.length, a2 = 0, c2 = 0, d2 = 0;
  for (; l2--; )
    o2 = t2[c2], c2++, !h2 && o2.isGroup && o2.calcUis(), r2 = o2.margin, o2.zone.w = o2.w, o2.zone.h = o2.h + r2, o2.autoWidth ? (a2 = 0, o2.zone.x = i2.x + o2.dx, o2.zone.y = e2, e2 += o2.h + r2, d2 += o2.h + r2) : (0 === a2 && (d2 += o2.h + r2), o2.zone.x = i2.x + a2, o2.zone.y = e2, n2 = s.getWidth(o2), n2 ? o2.zone.w = o2.w = n2 : o2.fw && (o2.zone.w = o2.w = o2.fw), a2 += o2.zone.w, a2 >= i2.w && (e2 += o2.h + r2, a2 = 0));
  return d2;
}, findTarget: function(t2, i2) {
  let e2 = t2.length;
  for (; e2--; )
    if (s.onZone(t2[e2], i2.clientX, i2.clientY))
      return e2;
  return -1;
}, findZone: function(t2) {
  if (s.needReZone || t2) {
    for (var i2, e2 = s.ui.length; e2--; )
      i2 = s.ui[e2], s.getZone(i2), i2.isGui && i2.calcUis();
    s.needReZone = false;
  }
}, onZone: function(t2, s2, i2) {
  if (void 0 === s2 || void 0 === i2)
    return false;
  let e2 = t2.zone, h2 = s2 - e2.x, o2 = i2 - e2.y, n2 = h2 >= 0 && o2 >= 0 && h2 <= e2.w && o2 <= e2.h;
  return n2 ? t2.local.set(h2, o2) : t2.local.neg(), n2;
}, getWidth: function(t2) {
  return t2.getDom().clientWidth;
}, getZone: function(t2) {
  if (t2.isCanvasOnly)
    return;
  let s2 = t2.getDom().getBoundingClientRect();
  t2.zone = { x: s2.left, y: s2.top, w: s2.width, h: s2.height };
}, cursor: function(t2) {
  (t2 = t2 || "auto") !== s.oldCursor && (document.body.style.cursor = t2, s.oldCursor = t2);
}, toCanvas: function(t2, i2, e2, h2) {
  if (s.xmlserializer || (s.xmlserializer = new XMLSerializer()), h2 && null !== s.tmpTime && (clearTimeout(s.tmpTime), s.tmpTime = null), null !== s.tmpTime)
    return;
  s.lock && (s.tmpTime = setTimeout(function() {
    s.tmpTime = null;
  }, 10));
  let o2 = false;
  i2 === t2.canvas.width && e2 === t2.canvas.height || (o2 = true), null === s.tmpImage && (s.tmpImage = new Image());
  let n2 = s.tmpImage, r2 = s.xmlserializer.serializeToString(t2.content), l2 = '<svg xmlns="http://www.w3.org/2000/svg" width="' + i2 + '" height="' + e2 + '"><foreignObject style="pointer-events: none; left:0;" width="100%" height="100%">' + r2 + "</foreignObject></svg>";
  n2.onload = function() {
    let s2 = t2.canvas.getContext("2d");
    o2 ? (t2.canvas.width = i2, t2.canvas.height = e2) : s2.clearRect(0, 0, i2, e2), s2.drawImage(this, 0, 0), t2.onDraw();
  }, n2.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(l2), n2.crossOrigin = "";
}, setHidden: function() {
  null === s.hiddenImput && (s.hiddenImput = document.createElement("input"), s.hiddenImput.type = "text", s.hiddenSizer = document.createElement("div"), document.body.appendChild(s.hiddenImput), document.body.appendChild(s.hiddenSizer));
  let t2 = s.debugInput ? "" : "opacity:0; zIndex:0;", i2 = s.parent.css.txtselect + "padding:0; width:auto; height:auto; left:10px; top:auto; color:#FFF; background:#000;" + t2;
  s.hiddenImput.style.cssText = i2 + "bottom:10px;" + (s.debugInput ? "" : "transform:scale(0);"), s.hiddenSizer.style.cssText = i2 + "bottom:40px;", s.hiddenImput.style.width = s.input.clientWidth + "px", s.hiddenImput.value = s.str, s.hiddenSizer.innerHTML = s.str, s.hasFocus = true;
}, clearHidden: function(t2) {
  null !== s.hiddenImput && (s.hasFocus = false);
}, clickPos: function(t2) {
  let i2 = s.str.length, e2 = 0, h2 = 0;
  for (; i2-- && (e2 += s.textWidth(s.str[h2]), !(e2 >= t2)); )
    h2++;
  return h2;
}, upInput: function(t2, i2) {
  if (null === s.parent)
    return false;
  let e2 = false;
  if (i2) {
    let i3 = s.clickPos(t2);
    if (s.moveX = i3, -1 === s.startX)
      s.startX = i3, s.cursorId = i3, s.inputRange = [s.startX, s.startX];
    else {
      s.moveX !== s.startX && (s.startX > s.moveX ? s.inputRange = [s.moveX, s.startX] : s.inputRange = [s.startX, s.moveX]);
    }
    e2 = true;
  } else
    -1 !== s.startX && (s.hasFocus = true, s.hiddenImput.focus(), s.hiddenImput.selectionStart = s.inputRange[0], s.hiddenImput.selectionEnd = s.inputRange[1], s.startX = -1, e2 = true);
  return e2 && s.selectParent(), e2;
}, selectAll: function() {
  s.parent && (s.str = s.input.textContent, s.inputRange = [0, s.str.length], s.hasFocus = true, s.hiddenImput.focus(), s.hiddenImput.selectionStart = s.inputRange[0], s.hiddenImput.selectionEnd = s.inputRange[1], s.cursorId = s.inputRange[1], s.selectParent());
}, selectParent: function() {
  var t2 = s.textWidth(s.str.substring(0, s.cursorId)), i2 = s.textWidth(s.str.substring(0, s.inputRange[0])), e2 = s.textWidth(s.str.substring(s.inputRange[0], s.inputRange[1]));
  s.parent.select(t2, i2, e2, s.hiddenSizer.innerHTML);
}, textWidth: function(t2) {
  return null === s.hiddenSizer ? 0 : (t2 = t2.replace(/ /g, "&nbsp;"), s.hiddenSizer.innerHTML = t2, s.hiddenSizer.clientWidth);
}, clearInput: function() {
  null !== s.parent && (s.firstImput || s.parent.validate(true), s.clearHidden(), s.parent.unselect(), s.input.style.background = s.parent.colors.back, s.input.style.borderColor = s.parent.colors.border, s.parent.isEdit = false, s.input = null, s.parent = null, s.str = "", s.firstImput = true);
}, setInput: function(t2, i2) {
  s.clearInput(), s.input = t2, s.parent = i2, s.input.style.background = s.parent.colors.backoff, s.input.style.borderColor = s.parent.colors.select, s.str = s.input.textContent, s.setHidden();
}, keydown: function(t2) {
  if (null === s.parent)
    return;
  let i2 = t2.which;
  t2.shiftKey, s.firstImput = false, s.hasFocus && (window.focus(), s.hiddenImput.focus()), s.parent.isEdit = true, 13 === i2 ? s.clearInput() : s.input.isNum ? t2.keyCode > 47 && t2.keyCode < 58 || t2.keyCode > 95 && t2.keyCode < 106 || 190 === t2.keyCode || 110 === t2.keyCode || 8 === t2.keyCode || 109 === t2.keyCode ? s.hiddenImput.readOnly = false : s.hiddenImput.readOnly = true : s.hiddenImput.readOnly = false;
}, keyup: function(t2) {
  null !== s.parent && (s.str = s.hiddenImput.value, s.parent.allEqual ? s.parent.sameStr(s.str) : s.input.textContent = s.str, s.cursorId = s.hiddenImput.selectionStart, s.inputRange = [s.hiddenImput.selectionStart, s.hiddenImput.selectionEnd], s.selectParent(), s.parent.validate());
}, loop: function() {
  s.isLoop && requestAnimationFrame(s.loop), s.update();
}, update: function() {
  let t2 = s.listens.length;
  for (; t2--; )
    s.listens[t2].listening();
}, removeListen: function(t2) {
  let i2 = s.listens.indexOf(t2);
  -1 !== i2 && s.listens.splice(i2, 1), 0 === s.listens.length && (s.isLoop = false);
}, addListen: function(t2) {
  return -1 === s.listens.indexOf(t2) && (s.listens.push(t2), s.isLoop || (s.isLoop = true, s.loop()), true);
} };
var i = s;
var e = { transition: 0.2, frag: document.createDocumentFragment(), colorRing: null, joystick_0: null, joystick_1: null, circular: null, knob: null, pad2d: null, svgns: "http://www.w3.org/2000/svg", links: "http://www.w3.org/1999/xlink", htmls: "http://www.w3.org/1999/xhtml", DOM_SIZE: ["height", "width", "top", "left", "bottom", "right", "margin-left", "margin-right", "margin-top", "margin-bottom"], SVG_TYPE_D: ["pattern", "defs", "transform", "stop", "animate", "radialGradient", "linearGradient", "animateMotion", "use", "filter", "feColorMatrix"], SVG_TYPE_G: ["svg", "rect", "circle", "path", "polygon", "text", "g", "line", "foreignObject"], PI: Math.PI, TwoPI: 2 * Math.PI, pi90: 0.5 * Math.PI, pi60: Math.PI / 3, torad: Math.PI / 180, todeg: 180 / Math.PI, clamp: (t2, s2, i2) => t2 = (t2 = t2 < s2 ? s2 : t2) > i2 ? i2 : t2, isDivid: (t2) => 0.5 * t2 === Math.floor(0.5 * t2), size: { w: 240, h: 20, p: 30, s: 8 }, defineColor: (t2, s2 = e.colors) => {
  let i2 = { ...s2 }, h2 = ["fontFamily", "fontWeight", "fontShadow", "fontSize"], o2 = false;
  t2.font && (t2.fontFamily = t2.font), t2.shadow && (t2.fontShadow = t2.shadow), t2.weight && (t2.fontWeight = t2.weight), t2.fontColor && (t2.text = t2.fontColor), t2.color && (t2.text = t2.color), t2.text && (i2.text = t2.text, t2.fontColor || t2.color || (i2.title = e.ColorLuma(t2.text, -0.25), i2.titleoff = e.ColorLuma(t2.text, -0.5)), i2.textOver = e.ColorLuma(t2.text, 0.25), i2.textSelect = e.ColorLuma(t2.text, 0.5)), t2.button && (i2.button = t2.button, i2.border = e.ColorLuma(t2.button, 0.1), i2.overoff = e.ColorLuma(t2.button, 0.2)), t2.select && (i2.select = t2.select, i2.over = e.ColorLuma(t2.select, -0.1)), t2.itemBg && (t2.back = t2.itemBg), t2.back && (i2.back = t2.back, i2.backoff = e.ColorLuma(t2.back, -0.1)), t2.fontSelect && (i2.textSelect = t2.fontSelect), t2.groupBorder && (i2.gborder = t2.groupBorder), t2.bgOver && (i2.backgroundOver = t2.bgOver);
  for (let s3 in i2)
    void 0 !== t2[s3] && (i2[s3] = t2[s3]);
  for (let s3 in t2)
    -1 !== h2.indexOf(s3) && (o2 = true);
  return o2 && e.defineText(i2), i2;
}, colors: { sx: 4, sy: 2, radius: 2, showOver: 1, content: "none", background: "rgba(50,50,50,0.15)", backgroundOver: "rgba(50,50,50,0.3)", title: "#CCC", titleoff: "#BBB", text: "#DDD", textOver: "#EEE", textSelect: "#FFF", back: "rgba(0,0,0,0.2)", backoff: "rgba(0,0,0,0.3)", border: "#4c4c4c", borderSize: 1, gborder: "none", groups: "none", button: "#3c3c3c", overoff: "#5c5c5c", over: "#024699", select: "#308AFF", action: "#FF3300", fontFamily: "Consolas, monospace", fontWeight: "normal", fontShadow: "none", fontSize: 12, joyOver: "rgba(48,138,255,0.25)", joyOut: "rgba(100,100,100,0.5)", joySelect: "#308AFF", hide: "rgba(0,0,0,0)" }, css: { basic: "position:absolute; pointer-events:none; box-sizing:border-box; margin:0; padding:0; overflow:hidden; -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select:none;", button: "display:flex; align-items:center; justify-content:center; text-align:center;", middle: "display:flex; align-items:center; justify-content:left; text-align:left; flex-direction: row-reverse;" }, svgs: { g1: "M 6 4 L 0 4 0 6 6 6 6 4 M 6 0 L 0 0 0 2 6 2 6 0 Z", g2: "M 6 0 L 4 0 4 6 6 6 6 0 M 2 0 L 0 0 0 6 2 6 2 0 Z", group: "M 7 7 L 7 8 8 8 8 7 7 7 M 5 7 L 5 8 6 8 6 7 5 7 M 3 7 L 3 8 4 8 4 7 3 7 M 7 5 L 7 6 8 6 8 5 7 5 M 6 6 L 6 5 5 5 5 6 6 6 M 7 3 L 7 4 8 4 8 3 7 3 M 6 4 L 6 3 5 3 5 4 6 4 M 3 5 L 3 6 4 6 4 5 3 5 M 3 3 L 3 4 4 4 4 3 3 3 Z", arrow: "M 3 8 L 8 5 3 2 3 8 Z", arrowDown: "M 5 8 L 8 3 2 3 5 8 Z", arrowUp: "M 5 2 L 2 7 8 7 5 2 Z", solid: "M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 Z", body: "M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 M 5 4 L 4 5 4 10 9 10 10 9 10 4 5 4 Z", vehicle: "M 13 6 L 11 1 3 1 1 6 1 13 3 13 3 11 11 11 11 13 13 13 13 6 M 2.4 6 L 4 2 10 2 11.6 6 2.4 6 M 12 8 L 12 10 10 10 10 8 12 8 M 4 8 L 4 10 2 10 2 8 4 8 Z", articulation: "M 13 9 L 12 9 9 2 9 1 5 1 5 2 2 9 1 9 1 13 5 13 5 9 4 9 6 5 8 5 10 9 9 9 9 13 13 13 13 9 Z", character: "M 13 4 L 12 3 9 4 5 4 2 3 1 4 5 6 5 8 4 13 6 13 7 9 8 13 10 13 9 8 9 6 13 4 M 6 1 L 6 3 8 3 8 1 6 1 Z", terrain: "M 13 8 L 12 7 Q 9.06 -3.67 5.95 4.85 4.04 3.27 2 7 L 1 8 7 13 13 8 M 3 8 Q 3.78 5.420 5.4 6.6 5.20 7.25 5 8 L 7 8 Q 8.39 -0.16 11 8 L 7 11 3 8 Z", joint: "M 7.7 7.7 Q 8 7.45 8 7 8 6.6 7.7 6.3 7.45 6 7 6 6.6 6 6.3 6.3 6 6.6 6 7 6 7.45 6.3 7.7 6.6 8 7 8 7.45 8 7.7 7.7 M 3.35 8.65 L 1 11 3 13 5.35 10.65 Q 6.1 11 7 11 8.28 11 9.25 10.25 L 7.8 8.8 Q 7.45 9 7 9 6.15 9 5.55 8.4 5 7.85 5 7 5 6.54 5.15 6.15 L 3.7 4.7 Q 3 5.712 3 7 3 7.9 3.35 8.65 M 10.25 9.25 Q 11 8.28 11 7 11 6.1 10.65 5.35 L 13 3 11 1 8.65 3.35 Q 7.9 3 7 3 5.7 3 4.7 3.7 L 6.15 5.15 Q 6.54 5 7 5 7.85 5 8.4 5.55 9 6.15 9 7 9 7.45 8.8 7.8 L 10.25 9.25 Z", ray: "M 9 11 L 5 11 5 12 9 12 9 11 M 12 5 L 11 5 11 9 12 9 12 5 M 11.5 10 Q 10.9 10 10.45 10.45 10 10.9 10 11.5 10 12.2 10.45 12.55 10.9 13 11.5 13 12.2 13 12.55 12.55 13 12.2 13 11.5 13 10.9 12.55 10.45 12.2 10 11.5 10 M 9 10 L 10 9 2 1 1 2 9 10 Z", collision: "M 11 12 L 13 10 10 7 13 4 11 2 7.5 5.5 9 7 7.5 8.5 11 12 M 3 2 L 1 4 4 7 1 10 3 12 8 7 3 2 Z", map: "M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z", material: "M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z", texture: "M 13 4 L 13 1 1 1 1 4 5 4 5 13 9 13 9 4 13 4 Z", object: "M 10 1 L 7 4 4 1 1 1 1 13 4 13 4 5 7 8 10 5 10 13 13 13 13 1 10 1 Z", none: "M 9 5 L 5 5 5 9 9 9 9 5 Z", cursor: "M 4 7 L 1 10 1 12 2 13 4 13 7 10 9 14 14 0 0 5 4 7 Z", load: "M 13 8 L 11.5 6.5 9 9 9 3 5 3 5 9 2.5 6.5 1 8 7 14 13 8 M 9 2 L 9 0 5 0 5 2 9 2 Z", save: "M 9 12 L 5 12 5 14 9 14 9 12 M 11.5 7.5 L 13 6 7 0 1 6 2.5 7.5 5 5 5 11 9 11 9 5 11.5 7.5 Z", extern: "M 14 14 L 14 0 0 0 0 14 14 14 M 12 6 L 12 12 2 12 2 6 12 6 M 12 2 L 12 4 2 4 2 2 12 2 Z" }, rezone() {
  i.needReZone = true;
}, getImput: function() {
  return !!i.input;
}, setStyle: function(t2) {
  for (var s2 in t2)
    e.colors[s2] && (e.colors[s2] = t2[s2]);
  e.setText();
}, defineText: function(t2) {
  e.setText(t2.fontSize, t2.text, t2.fontFamily, t2.fontShadow, t2.fontWeight);
}, setText: function(t2, s2, i2, h2, o2) {
  let n2 = e.colors;
  void 0 === i2 && (i2 = n2.fontFamily), void 0 === t2 && (t2 = n2.fontSize), void 0 === h2 && (h2 = n2.fontShadow), void 0 === o2 && (o2 = n2.fontWeight), void 0 === s2 && (s2 = n2.text), isNaN(t2) ? -1 === t2.search("em") && (t2 += "px") : t2 += "px", e.css.txt = e.css.basic + e.css.middle + " font-family:" + i2 + "; font-weight:" + o2 + "; font-size:" + t2 + "; color:" + n2.text + "; padding:0px 8px; left:0; top:2px; height:16px; width:100px; overflow:hidden; white-space: nowrap; letter-spacing: normal;", "none" !== h2 && (e.css.txt += " text-shadow: 1px 1px 1px " + h2 + ";"), e.css.txtselect = e.css.txt + "padding:0px 4px; border:1px dashed " + n2.border + ";", e.css.item = e.css.txt + "padding:0px 4px; position:relative; margin-bottom:1px; ";
}, cloneCss: function() {
  return { ...e.css };
}, clone: function(t2) {
  return t2.cloneNode(true);
}, setSvg: function(t2, s2, i2, e2, h2) {
  -1 === e2 ? t2.setAttributeNS(null, s2, i2) : void 0 !== h2 ? t2.childNodes[e2 || 0].childNodes[h2 || 0].setAttributeNS(null, s2, i2) : t2.childNodes[e2 || 0].setAttributeNS(null, s2, i2);
}, setCss: function(t2, s2) {
  for (let i2 in s2)
    -1 !== e.DOM_SIZE.indexOf(i2) ? t2.style[i2] = s2[i2] + "px" : t2.style[i2] = s2[i2];
}, set: function(t2, s2) {
  for (let i2 in s2)
    "txt" === i2 && (t2.textContent = s2[i2]), "link" === i2 ? t2.setAttributeNS(e.links, "xlink:href", s2[i2]) : t2.setAttributeNS(null, i2, s2[i2]);
}, get: function(t2, s2) {
  if (void 0 === s2)
    return t2;
  if (!isNaN(s2))
    return t2.childNodes[s2];
  if (s2 instanceof Array) {
    if (2 === s2.length)
      return t2.childNodes[s2[0]].childNodes[s2[1]];
    if (3 === s2.length)
      return t2.childNodes[s2[0]].childNodes[s2[1]].childNodes[s2[2]];
  }
}, dom: function(t2, s2, i2, h2, o2) {
  return t2 = t2 || "div", -1 !== e.SVG_TYPE_D.indexOf(t2) || -1 !== e.SVG_TYPE_G.indexOf(t2) ? "svg" === t2 ? (h2 = document.createElementNS(e.svgns, "svg"), e.set(h2, i2)) : (void 0 === h2 && (h2 = document.createElementNS(e.svgns, "svg")), e.addAttributes(h2, t2, i2, o2)) : h2 = void 0 === h2 ? document.createElementNS(e.htmls, t2) : h2.appendChild(document.createElementNS(e.htmls, t2)), s2 && (h2.style.cssText = s2), void 0 === o2 ? h2 : h2.childNodes[o2 || 0];
}, addAttributes: function(t2, s2, i2, h2) {
  let o2 = document.createElementNS(e.svgns, s2);
  return e.set(o2, i2), e.get(t2, h2).appendChild(o2), -1 !== e.SVG_TYPE_G.indexOf(s2) && (o2.style.pointerEvents = "none"), o2;
}, clear: function(t2) {
  for (e.purge(t2); t2.firstChild; )
    t2.firstChild.firstChild && e.clear(t2.firstChild), t2.removeChild(t2.firstChild);
}, purge: function(t2) {
  let s2, i2, h2 = t2.attributes;
  if (h2)
    for (s2 = h2.length; s2--; )
      i2 = h2[s2].name, "function" == typeof t2[i2] && (t2[i2] = null);
  if (h2 = t2.childNodes, h2)
    for (s2 = h2.length; s2--; )
      e.purge(t2.childNodes[s2]);
}, addSVGGlowEffect: function() {
  if (null !== document.getElementById("UILGlow"))
    return;
  let t2 = e.initUILEffects(), s2 = e.addAttributes(t2, "filter", { id: "UILGlow", x: "-20%", y: "-20%", width: "140%", height: "140%" });
  e.addAttributes(s2, "feGaussianBlur", { in: "SourceGraphic", stdDeviation: "3", result: "uilBlur" });
  let i2 = e.addAttributes(s2, "feMerge", {});
  for (let t3 = 0; t3 <= 3; t3++)
    e.addAttributes(i2, "feMergeNode", { in: "uilBlur" });
  e.addAttributes(i2, "feMergeNode", { in: "SourceGraphic" });
}, initUILEffects: function() {
  let t2 = document.getElementById("UILSVGEffects");
  return null === t2 && (t2 = e.dom("svg", void 0, { id: "UILSVGEffects", width: "0", height: "0" }), document.body.appendChild(t2)), t2;
}, ColorLuma: function(t2, s2) {
  "n" === t2 && (t2 = "#000"), (t2 = String(t2).replace(/[^0-9a-f]/gi, "")).length < 6 && (t2 = t2[0] + t2[0] + t2[1] + t2[1] + t2[2] + t2[2]), s2 = s2 || 0;
  let i2, e2, h2 = "#";
  for (e2 = 0; e2 < 3; e2++)
    i2 = parseInt(t2.substr(2 * e2, 2), 16), i2 = Math.round(Math.min(Math.max(0, i2 + i2 * s2), 255)).toString(16), h2 += ("00" + i2).substr(i2.length);
  return h2;
}, findDeepInver: function(t2) {
  return 0.3 * t2[0] + 0.59 * t2[1] + 0.11 * t2[2] <= 0.6;
}, lerpColor: function(t2, s2, i2) {
  let e2 = {};
  for (let h2 = 0; h2 < 3; h2++)
    e2[h2] = t2[h2] + (s2[h2] - t2[h2]) * i2;
  return e2;
}, hexToHtml: function(t2) {
  return "#" + ("000000" + (t2 = void 0 === t2 ? 0 : t2).toString(16)).substr(-6);
}, htmlToHex: function(t2) {
  return t2.toUpperCase().replace("#", "0x");
}, u255: function(t2, s2) {
  return parseInt(t2.substring(s2, s2 + 2), 16) / 255;
}, u16: function(t2, s2) {
  return parseInt(t2.substring(s2, s2 + 1), 16) / 15;
}, unpack: function(t2) {
  return 7 == t2.length ? [e.u255(t2, 1), e.u255(t2, 3), e.u255(t2, 5)] : 4 == t2.length ? [e.u16(t2, 1), e.u16(t2, 2), e.u16(t2, 3)] : void 0;
}, p255: function(t2) {
  let s2 = Math.round(255 * t2).toString(16);
  return s2.length < 2 && (s2 = "0" + s2), s2;
}, pack: function(t2) {
  return "#" + e.p255(t2[0]) + e.p255(t2[1]) + e.p255(t2[2]);
}, htmlRgb: function(t2) {
  return "rgb(" + Math.round(255 * t2[0]) + "," + Math.round(255 * t2[1]) + "," + Math.round(255 * t2[2]) + ")";
}, pad: function(t2) {
  return 1 == t2.length && (t2 = "0" + t2), t2;
}, rgbToHex: function(t2) {
  let s2 = Math.round(255 * t2[0]).toString(16), i2 = Math.round(255 * t2[1]).toString(16), h2 = Math.round(255 * t2[2]).toString(16);
  return "#" + e.pad(s2) + e.pad(i2) + e.pad(h2);
}, hueToRgb: function(t2, s2, i2) {
  return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? t2 + 6 * (s2 - t2) * i2 : i2 < 0.5 ? s2 : i2 < 2 / 3 ? t2 + 6 * (s2 - t2) * (2 / 3 - i2) : t2;
}, rgbToHsl: function(t2) {
  let s2 = t2[0], i2 = t2[1], e2 = t2[2], h2 = Math.min(s2, i2, e2), o2 = Math.max(s2, i2, e2), n2 = o2 - h2, r2 = 0, l2 = 0, a2 = (h2 + o2) / 2;
  return a2 > 0 && a2 < 1 && (l2 = n2 / (a2 < 0.5 ? 2 * a2 : 2 - 2 * a2)), n2 > 0 && (o2 == s2 && o2 != i2 && (r2 += (i2 - e2) / n2), o2 == i2 && o2 != e2 && (r2 += 2 + (e2 - s2) / n2), o2 == e2 && o2 != s2 && (r2 += 4 + (s2 - i2) / n2), r2 /= 6), [r2, l2, a2];
}, hslToRgb: function(t2) {
  let s2, i2, h2 = t2[0], o2 = t2[1], n2 = t2[2];
  return 0 === o2 ? [n2, n2, n2] : (i2 = n2 <= 0.5 ? n2 * (o2 + 1) : n2 + o2 - n2 * o2, s2 = 2 * n2 - i2, [e.hueToRgb(s2, i2, h2 + 0.33333), e.hueToRgb(s2, i2, h2), e.hueToRgb(s2, i2, h2 - 0.33333)]);
}, makeGradiant: function(t2, s2, i2, h2) {
  e.dom(t2, null, s2, i2, 0);
  let o2, n2 = i2.childNodes[0].childNodes.length - 1;
  for (let t3 = 0; t3 < h2.length; t3++)
    o2 = h2[t3], e.dom("stop", null, { offset: o2[0] + "%", "stop-color": o2[1], "stop-opacity": o2[2] }, i2, [0, n2]);
}, makePad: function(t2) {
  let s2 = 256, i2 = e.dom("svg", e.css.basic + "position:relative;", { viewBox: "0 0 256 256", width: s2, height: s2, preserveAspectRatio: "none" }), o2 = 200, n2 = 28;
  h.dom("rect", "", { x: n2, y: n2, width: o2, height: o2, fill: e.colors.back }, i2), h.dom("rect", "", { x: 38, y: 38, width: 180, height: 180, fill: e.colors.button }, i2), h.dom("line", "", { x1: 38, y1: 128, x2: 218, y2: 128, stroke: e.colors.back, "stroke-width": 2 }, i2), h.dom("line", "", { x1: 128, x2: 128, y1: 38, y2: 218, stroke: e.colors.back, "stroke-width": 2 }, i2), h.dom("circle", "", { cx: 128, cy: 128, r: 5, stroke: e.colors.text, "stroke-width": 5, fill: "none" }, i2), e.pad2d = i2;
}, makeKnob: function(t2) {
  let s2 = 128, i2 = e.dom("svg", e.css.basic + "position:relative;", { viewBox: "0 0 128 " + s2, width: s2, height: s2, preserveAspectRatio: "none" });
  e.dom("circle", "", { cx: 64, cy: 64, r: 34, fill: e.colors.button, stroke: "rgba(0,0,0,0.3)", "stroke-width": 8 }, i2), e.dom("path", "", { d: "", stroke: e.colors.text, "stroke-width": 4, fill: "none", "stroke-linecap": "round" }, i2), e.dom("circle", "", { cx: 64, cy: 64, r: 41, stroke: "rgba(0,0,0,0.1)", "stroke-width": 7, fill: "none" }, i2), e.dom("path", "", { d: "", stroke: "rgba(255,255,255,0.3)", "stroke-width": 2, fill: "none", "stroke-linecap": "round", "stroke-opacity": 0.5 }, i2), e.knob = i2;
}, makeCircular: function(t2) {
  let s2 = 128, i2 = e.dom("svg", e.css.basic + "position:relative;", { viewBox: "0 0 128 " + s2, width: s2, height: s2, preserveAspectRatio: "none" });
  e.dom("circle", "", { cx: 64, cy: 64, r: 40, stroke: "rgba(0,0,0,0.1)", "stroke-width": 10, fill: "none" }, i2), e.dom("path", "", { d: "", stroke: e.colors.text, "stroke-width": 7, fill: "none", "stroke-linecap": "butt" }, i2), e.circular = i2;
}, makeJoystick: function(t2) {
  let s2, i2 = 128, h2 = Math.floor(49), o2 = Math.floor(0.6 * h2), n2 = e.dom("svg", e.css.basic + "position:relative;", { viewBox: "0 0 128 " + i2, width: i2, height: i2, preserveAspectRatio: "none" });
  if (e.dom("defs", null, {}, n2), e.dom("g", null, {}, n2), 0 === t2) {
    s2 = [[40, "rgb(0,0,0)", 0.3], [80, "rgb(0,0,0)", 0], [90, "rgb(50,50,50)", 0.4], [100, "rgb(50,50,50)", 0]], e.makeGradiant("radialGradient", { id: "grad", cx: "50%", cy: "50%", r: "50%", fx: "50%", fy: "50%" }, n2, s2), s2 = [[60, "rgb(0,0,0)", 0.5], [100, "rgb(0,0,0)", 0]], e.makeGradiant("radialGradient", { id: "gradS", cx: "50%", cy: "50%", r: "50%", fx: "50%", fy: "50%" }, n2, s2);
    let t3 = ["rgb(40,40,40)", "rgb(48,48,48)", "rgb(30,30,30)"], i3 = ["rgb(1,90,197)", "rgb(3,95,207)", "rgb(0,65,167)"];
    s2 = [[30, t3[0], 1], [60, t3[1], 1], [80, t3[1], 1], [100, t3[2], 1]], e.makeGradiant("radialGradient", { id: "gradIn", cx: "50%", cy: "50%", r: "50%", fx: "50%", fy: "50%" }, n2, s2), s2 = [[30, i3[0], 1], [60, i3[1], 1], [80, i3[1], 1], [100, i3[2], 1]], e.makeGradiant("radialGradient", { id: "gradIn2", cx: "50%", cy: "50%", r: "50%", fx: "50%", fy: "50%" }, n2, s2), e.dom("circle", "", { cx: 64, cy: 64, r: h2, fill: "url(#grad)" }, n2), e.dom("circle", "", { cx: 69, cy: 74, r: o2 + 10, fill: "url(#gradS)" }, n2), e.dom("circle", "", { cx: 64, cy: 64, r: o2, fill: "url(#gradIn)" }, n2), e.joystick_0 = n2;
  } else
    s2 = [[69, "rgb(0,0,0)", 0], [70, "rgb(0,0,0)", 0.3], [100, "rgb(0,0,0)", 0]], e.makeGradiant("radialGradient", { id: "gradX", cx: "50%", cy: "50%", r: "50%", fx: "50%", fy: "50%" }, n2, s2), e.dom("circle", "", { cx: 64, cy: 64, r: h2, fill: "none", stroke: "rgba(100,100,100,0.25)", "stroke-width": "4" }, n2), e.dom("circle", "", { cx: 64, cy: 64, r: o2 + 14, fill: "url(#gradX)" }, n2), e.dom("circle", "", { cx: 64, cy: 64, r: o2, fill: "none", stroke: "rgb(100,100,100)", "stroke-width": "4" }, n2), e.joystick_1 = n2;
}, makeColorRing: function() {
  let t2 = 256, s2 = e.dom("svg", e.css.basic + "position:relative;", { viewBox: "0 0 256 " + t2, width: t2, height: t2, preserveAspectRatio: "none" });
  e.dom("defs", null, {}, s2), e.dom("g", null, {}, s2);
  let i2, h2, o2, n2, r2, l2, a2, c2, d2, u2 = 128, p2 = 8 / 113 / 24 * Math.PI, m2 = 0, g2 = [];
  for (l2 = 0; l2 <= 24; ++l2) {
    if (o2 = l2 / 24, n2 = o2 * e.TwoPI, i2 = 0.5 * (m2 + n2), h2 = 1 / Math.cos(0.5 * (n2 - m2)), r2 = [Math.sin(m2), -Math.cos(m2), Math.sin(i2) * h2, -Math.cos(i2) * h2, Math.sin(n2), -Math.cos(n2)], g2[1] = e.rgbToHex(e.hslToRgb([o2, 1, 0.5])), l2 > 0) {
      for (a2 = 6; a2--; )
        r2[a2] = (113 * r2[a2] + u2).toFixed(2);
      c2 = " M" + r2[0] + " " + r2[1] + " Q" + r2[2] + " " + r2[3] + " " + r2[4] + " " + r2[5], d2 = [[0, g2[0], 1], [100, g2[1], 1]], e.makeGradiant("linearGradient", { id: "G" + l2, x1: r2[0], y1: r2[1], x2: r2[4], y2: r2[5], gradientUnits: "userSpaceOnUse" }, s2, d2), e.dom("path", "", { d: c2, "stroke-width": 30, stroke: "url(#G" + l2 + ")", "stroke-linecap": "butt" }, s2, 1);
    }
    m2 = n2 - p2, g2[0] = g2[1];
  }
  d2 = [[0, "#FFFFFF", 1], [50, "#FFFFFF", 0], [50, "#000000", 0], [100, "#000000", 1]], e.makeGradiant("linearGradient", { id: "GL0", x1: 0, y1: u2 - 84.9, x2: 0, y2: 212.9, gradientUnits: "userSpaceOnUse" }, s2, d2), d2 = [[0, "#7f7f7f", 1], [50, "#7f7f7f", 0.5], [100, "#7f7f7f", 0]], e.makeGradiant("linearGradient", { id: "GL1", x1: 78.95, y1: 0, x2: 226, y2: 0, gradientUnits: "userSpaceOnUse" }, s2, d2), e.dom("g", null, { "transform-origin": "128px 128px", transform: "rotate(0)" }, s2), e.dom("polygon", "", { points: "78.95 43.1 78.95 212.85 226 128", fill: "red" }, s2, 2), e.dom("polygon", "", { points: "78.95 43.1 78.95 212.85 226 128", fill: "url(#GL1)", "stroke-width": 1, stroke: "url(#GL1)" }, s2, 2), e.dom("polygon", "", { points: "78.95 43.1 78.95 212.85 226 128", fill: "url(#GL0)", "stroke-width": 1, stroke: "url(#GL0)" }, s2, 2), e.dom("path", "", { d: "M 255.75 136.5 Q 256 132.3 256 128 256 123.7 255.75 119.5 L 241 128 255.75 136.5 Z", fill: "none", "stroke-width": 2, stroke: "#000" }, s2, 2), e.dom("circle", "", { cx: 128, cy: 128, r: 6, "stroke-width": 2, stroke: "#000", fill: "none" }, s2), e.colorRing = s2;
}, icon: function(t2, s2, i2) {
  i2 = i2 || 40;
  let h2 = ["<svg xmlns='" + e.svgns + "' version='1.1' xmlns:xlink='" + e.htmls + "' style='pointer-events:none;' preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='" + i2 + "px' height='" + i2 + "px' viewBox='0 0 256 256'><g>"];
  switch (t2) {
    case "logo":
      h2[1] = "<path id='logoin' fill='" + s2 + "' stroke='none' d='" + e.logoFill_d + "'/>";
      break;
    case "donate":
      h2[1] = "<path id='logoin' fill='" + s2 + "' stroke='none' d='" + e.logo_donate + "'/>";
      break;
    case "neo":
      h2[1] = "<path id='logoin' fill='" + s2 + "' stroke='none' d='" + e.logo_neo + "'/>";
      break;
    case "phy":
      h2[1] = "<path id='logoin' stroke='" + s2 + "' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='" + e.logo_phy + "'/>";
      break;
    case "config":
      h2[1] = "<path id='logoin' stroke='" + s2 + "' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='" + e.logo_config + "'/>";
      break;
    case "github":
      h2[1] = "<path id='logoin' fill='" + s2 + "' stroke='none' d='" + e.logo_github + "'/>";
      break;
    case "save":
      h2[1] = "<path stroke='" + s2 + "' stroke-width='4' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 26.125 17 L 20 22.95 14.05 17 M 20 9.95 L 20 22.95'/><path stroke='" + s2, h2[1] += "' stroke-width='2.5' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 32.6 23 L 32.6 25.5 Q 32.6 28.5 29.6 28.5 L 10.6 28.5 Q 7.6 28.5 7.6 25.5 L 7.6 23'/>";
  }
  return h2[2] = "</g></svg>", h2.join("\n");
}, logoFill_d: "\n    M 171 150.75 L 171 33.25 155.5 33.25 155.5 150.75 Q 155.5 162.2 147.45 170.2 139.45 178.25 128 178.25 116.6 178.25 108.55 170.2 100.5 162.2 100.5 150.75 \n    L 100.5 33.25 85 33.25 85 150.75 Q 85 168.65 97.55 181.15 110.15 193.75 128 193.75 145.9 193.75 158.4 181.15 171 168.65 171 150.75 \n    M 200 33.25 L 184 33.25 184 150.8 Q 184 174.1 167.6 190.4 151.3 206.8 128 206.8 104.75 206.8 88.3 190.4 72 174.1 72 150.8 L 72 33.25 56 33.25 56 150.75 \n    Q 56 180.55 77.05 201.6 98.2 222.75 128 222.75 157.8 222.75 178.9 201.6 200 180.55 200 150.75 L 200 33.25 Z\n    ", logo_github: "\n    M 180.5 70 Q 186.3 82.4 181.55 96.55 196.5 111.5 189.7 140.65 183.65 168.35 146 172.7 152.5 178.7 152.55 185.9 L 152.55 218.15 Q 152.84 224.56 159.15 223.3 \n    159.21 223.3 159.25 223.3 181.14 216.25 198.7 198.7 228 169.4 228 128 228 86.6 198.7 57.3 169.4 28 128 28 86.6 28 57.3 57.3 28 86.6 28 128 28 169.4 57.3 198.7 74.85 \n    216.25 96.75 223.3 96.78 223.3 96.8 223.3 103.16 224.54 103.45 218.15 L 103.45 200 Q 82.97 203.1 75.1 196.35 69.85 191.65 68.4 185.45 64.27 177.055 59.4 174.15 49.20 \n    166.87 60.8 167.8 69.85 169.61 75.7 180 81.13 188.09 90 188.55 98.18 188.86 103.45 185.9 103.49 178.67 110 172.7 72.33 168.33 66.3 140.65 59.48 111.49 74.45 96.55 69.7 \n    82.41 75.5 70 84.87 68.74 103.15 80 115.125 76.635 128 76.85 140.85 76.65 152.85 80 171.1 68.75 180.5 70 Z\n    ", logo_neo: "\n    M 219 52 L 206 52 206 166 Q 206 183.4 193.75 195.65 181.4 208 164 208 146.6 208 134.35 195.65 122 183.4 122 166 L 122 90 Q 122 77.6 113.15 68.85 104.4 60 92 60 79.55 \n    60 70.75 68.85 62 77.6 62 90 L 62 204 75 204 75 90 Q 75 83 79.95 78 84.95 73 92 73 99 73 104 78 109 83 109 90 L 109 166 Q 109 188.8 125.15 204.85 141.2 221 164 221 \n    186.75 221 202.95 204.85 219 188.8 219 166 L 219 52 M 194 52 L 181 52 181 166 Q 181 173 176.05 178 171.05 183 164 183 157 183 152 178 147 173 147 166 L 147 90 Q 147 \n    67.2 130.85 51.15 114.8 35 92 35 69.25 35 53.05 51.15 37 67.2 37 90 L 37 204 50 204 50 90 Q 50 72.6 62.25 60.35 74.6 48 92 48 109.4 48 121.65 60.35 134 72.6 134 90 L \n    134 166 Q 134 178.4 142.85 187.15 151.6 196 164 196 176.45 196 185.25 187.15 194 178.4 194 166 L 194 52 Z\n    ", logo_phy: "\n    M 103.55 37.95 L 127.95 37.95 Q 162.35 37.95 186.5 55 210.9 72.35 210.9 96.5 210.9 120.65 186.5 137.7 162.35 155 127.95 155 L 127.95 237.95 M 127.95 155 \n    Q 93.55 155 69.15 137.7 45 120.65 45 96.5 45 72.35 69.15 55 70.9 53.8 72.85 52.85 M 127.95 155 L 127.95 37.95\n    ", logo_config: "\n    M 204.35 51.65 L 173.25 82.75 Q 192 101.5 192 128 L 236 128 M 192 128 Q 192 154.55 173.25 173.25 L 204.4 204.4 M 51.65 51.65 L 82.75 82.75 Q 101.5 64 128 64 \n    L 128 20 M 51.6 204.4 L 82.75 173.25 Q 64 154.55 64 128 L 20 128 M 128 236 L 128 192 Q 101.5 192 82.75 173.25 M 64 128 Q 64 101.5 82.75 82.75 M 173.25 173.25 \n    Q 154.55 192 128 192 M 128 64 Q 154.55 64 173.25 82.75\n    ", logo_donate: "\n    M 171.3 80.3 Q 179.5 62.15 171.3 45.8 164.1 32.5 141.35 30.1 L 94.35 30.1 Q 89.35 30.4 88.3 35.15 L 70.5 148.05 Q 70.2 152.5 73.7 152.6 L 100.95 152.6 107 111.6 Q 108.75 \n    106.55 112.6 106.45 130.45 108.05 145.3 103.9 163.35 98.75 171.3 80.3 M 179.8 71.5 Q 178.6 79.75 174.9 87.85 168.45 102.9 151.9 109.15 140.65 113.95 117.55 113 113.15 \n    112.75 111 117.45 L 102.7 169.95 Q 102.45 173.8 105.5 173.85 L 128.95 173.85 Q 132.2 174.2 133.35 169.65 L 138.3 139.95 Q 139.75 135.6 143.1 135.5 146.6 135.75 150.6 135.65 \n    154.55 135.5 157.35 135.1 160.15 134.7 166.75 132.35 181.35 127.4 187.9 111.2 194.25 95.75 189.5 81.95 186.75 74.85 179.8 71.5 M 103.5 209.9 Q 103.5 202.85 99.7 198.85 95.95 \n    194.75 89.4 194.75 82.8 194.75 79.05 198.85 75.3 202.9 75.3 209.9 75.3 216.85 79.05 220.95 82.8 225.05 89.4 225.05 95.95 225.05 99.7 221 103.5 216.95 103.5 209.9 M 95.45 205.5 \n    Q 95.95 207.3 95.95 209.9 95.95 212.65 95.45 214.35 94.95 216 94 217.3 93.1 218.45 91.9 219 90.7 219.55 89.4 219.55 88.15 219.55 86.95 219.05 85.75 218.55 84.8 217.3 83.9 216.15 \n    83.4 214.35 82.85 212.6 82.85 209.9 82.85 207.3 83.4 205.45 83.95 203.55 84.85 202.45 85.9 201.2 86.95 200.75 88.05 200.25 89.4 200.25 90.7 200.25 91.85 200.8 93.05 201.3 94 202.5 \n    94.9 203.65 95.45 205.5 M 153.3 195.35 L 145.3 195.35 135.5 224.45 142.8 224.45 144.6 218.5 153.75 218.5 155.6 224.45 163.1 224.45 153.3 195.35 M 152.15 213.25 L 146.25 213.25 \n    149.2 203.65 152.15 213.25 M 116.75 195.35 L 107.8 195.35 107.8 224.45 114.5 224.45 114.5 204.2 125.7 224.45 132.75 224.45 132.75 195.35 126.05 195.35 126.05 212.05 116.75 195.35 M \n    66.5 197.65 Q 64.15 196.15 61.45 195.75 58.8 195.35 55.75 195.35 L 46.7 195.35 46.7 224.45 55.8 224.45 Q 58.8 224.45 61.5 224.05 64.15 223.6 66.4 222.15 69.15 220.45 70.9 217.2 \n    72.7 214 72.7 209.95 72.7 205.7 71 202.6 69.35 199.5 66.5 197.65 M 64.2 205 Q 65.2 207 65.2 209.9 65.2 212.75 64.25 214.75 63.3 216.75 61.5 217.85 60 218.85 58.3 218.9 56.6 219 \n    54.15 219 L 54 219 54 200.8 54.15 200.8 Q 56.4 200.8 58.05 200.9 59.7 200.95 61.15 201.75 63.2 202.95 64.2 205 M 210.2 195.35 L 190.5 195.35 190.5 224.45 210.2 224.45 210.2 218.9 \n    197.75 218.9 197.75 211.55 209.2 211.55 209.2 206 197.75 206 197.75 200.9 210.2 200.9 210.2 195.35 M 187.5 195.35 L 163 195.35 163 200.9 171.6 200.9 171.6 224.45 178.9 224.45 178.9 \n    200.9 187.5 200.9 187.5 195.35 Z\n    " };
e.setText();
var h = e;
var o = class _o {
  static autoTypes(t2) {
    let s2 = [];
    switch (t2) {
      case "svg":
        s2 = [{ accept: { "image/svg+xml": ".svg" } }];
        break;
      case "wav":
        s2 = [{ accept: { "audio/wav": ".wav" } }];
        break;
      case "mp3":
        s2 = [{ accept: { "audio/mpeg": ".mp3" } }];
        break;
      case "mp4":
        s2 = [{ accept: { "video/mp4": ".mp4" } }];
        break;
      case "bin":
      case "hex":
        s2 = [{ description: "Binary Files", accept: { "application/octet-stream": [".bin", ".hex"] } }];
        break;
      case "text":
        s2 = [{ description: "Text Files", accept: { "text/plain": [".txt", ".text"], "text/html": [".html", ".htm"] } }];
        break;
      case "json":
        s2 = [{ description: "JSON Files", accept: { "application/json": [".json"] } }];
        break;
      case "js":
        s2 = [{ description: "JavaScript Files", accept: { "text/javascript": [".js"] } }];
        break;
      case "image":
        s2 = [{ description: "Images", accept: { "image/*": [".png", ".gif", ".jpeg", ".jpg"] } }];
        break;
      case "icon":
        s2 = [{ description: "Icons", accept: { "image/x-ico": [".ico"] } }];
        break;
      case "lut":
        s2 = [{ description: "Lut", accept: { "text/plain": [".cube", ".3dl"] } }];
    }
    return s2;
  }
  static async load(t2 = {}) {
    "function" != typeof window.showOpenFilePicker && (window.showOpenFilePicker = _o.showOpenFilePickerPolyfill);
    try {
      let s2 = t2.type || "";
      const i2 = { excludeAcceptAllOption: !!s2, multiple: false };
      i2.types = _o.autoTypes(s2);
      const e2 = await window.showOpenFilePicker(i2), h2 = await e2[0].getFile();
      if (!h2)
        return null;
      let n2 = h2.name, r2 = n2.substring(n2.lastIndexOf(".") + 1, n2.length);
      const l2 = ["png", "jpg", "jpeg", "mp4", "webm", "ogg", "mp3"], a2 = ["sea", "z", "hex", "bvh", "BVH", "glb", "gltf"], c2 = new FileReader();
      -1 !== l2.indexOf(r2) ? c2.readAsDataURL(h2) : -1 !== a2.indexOf(r2) ? c2.readAsArrayBuffer(h2) : c2.readAsText(h2), c2.onload = function(i3) {
        let e3 = i3.target.result;
        switch (s2) {
          case "image":
            let s3 = new Image();
            s3.onload = function() {
              t2.callback && t2.callback(s3, n2, r2);
            }, s3.src = e3;
            break;
          case "json":
            t2.callback && t2.callback(JSON.parse(e3), n2, r2);
            break;
          default:
            t2.callback && t2.callback(e3, n2, r2);
        }
      };
    } catch (s2) {
      console.log(s2), t2.always && t2.callback && t2.callback(null);
    }
  }
  static showOpenFilePickerPolyfill(t2) {
    return new Promise((s2) => {
      const i2 = document.createElement("input");
      i2.type = "file", i2.multiple = t2.multiple, i2.accept = t2.types.map((t3) => t3.accept).flatMap((t3) => Object.keys(t3).flatMap((s3) => t3[s3])).join(","), i2.addEventListener("change", () => {
        s2([...i2.files].map((t3) => ({ getFile: async () => new Promise((s3) => {
          s3(t3);
        }) })));
      }), i2.click();
    });
  }
  static async save(t2 = {}) {
    let s2 = false;
    "function" != typeof window.showSaveFilePicker && (window.showSaveFilePicker = _o.showSaveFilePickerPolyfill, s2 = true);
    try {
      let i2 = t2.type || "";
      const e2 = { suggestedName: t2.name || "hello", data: t2.data || "" };
      e2.types = _o.autoTypes(i2), e2.finalType = Object.keys(e2.types[0].accept)[0], e2.suggestedName += e2.types[0].accept[e2.finalType][0];
      const h2 = await window.showSaveFilePicker(e2);
      if (s2)
        return;
      const n2 = await h2.createWritable();
      let r2 = new Blob([e2.data], { type: e2.finalType });
      await n2.write(r2), await n2.close();
    } catch (t3) {
      console.log(t3);
    }
  }
  static showSaveFilePickerPolyfill(t2) {
    return new Promise((s2) => {
      const i2 = document.createElement("a");
      i2.download = t2.suggestedName || "my-file.txt";
      let e2 = new Blob([t2.data], { type: t2.finalType });
      i2.href = URL.createObjectURL(e2), i2.addEventListener("click", () => {
        s2(setTimeout(() => URL.revokeObjectURL(i2.href), 1e3));
      }), i2.click();
    });
  }
  static async getFolder() {
    try {
      const t2 = await window.showDirectoryPicker(), s2 = [];
      for await (const i2 of t2.values()) {
        const t3 = await i2.getFile();
        s2.push(t3);
      }
      return console.log(s2), s2;
    } catch (t2) {
      console.log(t2);
    }
  }
};
var n = class {
  constructor(t2 = 0, s2 = 0) {
    this.x = t2, this.y = s2;
  }
  set(t2, s2) {
    return this.x = t2, this.y = s2, this;
  }
  divide(t2) {
    return this.x /= t2.x, this.y /= t2.y, this;
  }
  multiply(t2) {
    return this.x *= t2.x, this.y *= t2.y, this;
  }
  multiplyScalar(t2) {
    return this.x *= t2, this.y *= t2, this;
  }
  divideScalar(t2) {
    return this.multiplyScalar(1 / t2);
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  angle() {
    var t2 = Math.atan2(this.y, this.x);
    return t2 < 0 && (t2 += 2 * Math.PI), t2;
  }
  addScalar(t2) {
    return this.x += t2, this.y += t2, this;
  }
  negate() {
    return this.x *= -1, this.y *= -1, this;
  }
  neg() {
    return this.x = -1, this.y = -1, this;
  }
  isZero() {
    return 0 === this.x && 0 === this.y;
  }
  copy(t2) {
    return this.x = t2.x, this.y = t2.y, this;
  }
  equals(t2) {
    return t2.x === this.x && t2.y === this.y;
  }
  nearEquals(t2, s2) {
    return t2.x.toFixed(s2) === this.x.toFixed(s2) && t2.y.toFixed(s2) === this.y.toFixed(s2);
  }
  lerp(t2, s2) {
    return null === t2 ? (this.x -= this.x * s2, this.y -= this.y * s2) : (this.x += (t2.x - this.x) * s2, this.y += (t2.y - this.y) * s2), this;
  }
};
var r = class {
  constructor(t2 = {}) {
    this.lock = t2.lock || false, this.neverlock = false, this.isSpace = t2.isSpace || false, this.main = t2.main || null, this.isUI = t2.isUI || false, this.group = t2.group || null, this.isListen = false, this.top = 0, this.ytop = 0, this.dx = t2.dx || 0, this.isSelectable = void 0 !== t2.selectable && t2.selectable, this.unselectable = void 0 !== t2.unselect ? t2.unselect : this.isSelectable, this.ontop = !!t2.ontop && t2.ontop, this.css = this.main ? this.main.css : h.css, this.colors = h.defineColor(t2, this.main ? this.group ? this.group.colors : this.main.colors : h.colors), this.overEffect = this.colors.showOver, this.svgs = h.svgs, this.zone = { x: 0, y: 0, w: 0, h: 0, d: 0 }, this.local = new n().neg(), this.isCanvasOnly = false, this.isSelect = false, this.p = void 0 !== t2.p ? t2.p : h.size.p, this.w = this.isUI ? this.main.size.w : h.size.w, void 0 !== t2.w && (this.w = t2.w), this.h = this.isUI ? this.main.size.h : h.size.h, void 0 !== t2.h && (this.h = t2.h), this.isSpace ? this.lock = true : this.h = this.h < 11 ? 11 : this.h, this.fw = t2.fw || 0, this.autoWidth = t2.auto || true, this.isOpen = false, this.radius = t2.radius || this.colors.radius, this.transition = t2.transition || h.transition, this.isNumber = false, this.noNeg = t2.noNeg || false, this.allEqual = t2.allEqual || false, this.mono = false, this.isEdit = false, this.simple = t2.simple || false, this.simple && (this.sa = 0), this.setSize(this.w), void 0 !== t2.sa && (this.sa = t2.sa), void 0 !== t2.sb && (this.sb = t2.sb), this.simple && (this.sb = this.w - this.sa), this.sc = void 0 === t2.sc ? 47 : t2.sc, this.objectLink = null, this.isSend = false, this.objectKey = null, this.txt = t2.name || "", this.name = t2.rename || this.txt, this.target = t2.target || null, this.callback = void 0 === t2.callback ? null : t2.callback, this.endCallback = null, this.openCallback = void 0 === t2.openCallback ? null : t2.openCallback, this.closeCallback = void 0 === t2.closeCallback ? null : t2.closeCallback, null === this.callback && this.isUI && null !== this.main.callback && (this.callback = this.group ? this.group.callback : this.main.callback), this.c = [], this.s = [], this.useFlex = !!this.isUI && this.main.useFlex;
    let s2 = this.useFlex ? "display:flex; justify-content:center; align-items:center; text-align:center; flex: 1 100%;" : "float:left;";
    this.c[0] = h.dom("div", this.css.basic + s2 + "position:relative; height:20px;"), this.s[0] = this.c[0].style, this.margin = this.colors.sy, this.mtop = 0;
    let i2 = h.isDivid(this.margin);
    if (this.isUI && this.margin && (this.s[0].boxSizing = "content-box", i2 ? (this.mtop = 0.5 * this.margin, this.s[0].borderTop = this.mtop + "px solid transparent", this.s[0].borderBottom = this.mtop + "px solid transparent") : this.s[0].borderBottom = this.margin + "px solid transparent"), this.simple || (this.c[1] = h.dom("div", this.css.txt + this.css.middle), this.s[1] = this.c[1].style, this.c[1].textContent = this.name, this.s[1].color = this.lock ? this.colors.titleoff : this.colors.title), t2.pos) {
      this.s[0].position = "absolute";
      for (let s3 in t2.pos)
        this.s[0][s3] = t2.pos[s3];
      this.mono = true;
    }
    t2.css && (this.s[0].cssText = t2.css);
  }
  init() {
    this.ytop = this.top + this.mtop, this.zone.h = this.h + this.margin, this.zone.w = this.w;
    let t2 = this.s, s2 = this.c;
    t2[0].height = this.h + "px", this.isUI && (t2[0].background = this.colors.background), !this.autoWidth && this.useFlex ? (t2[0].flex = "1 0 auto", t2[0].minWidth = this.minw + "px", t2[0].textAlign = "center") : this.isUI && (t2[0].width = "100%"), void 0 !== s2[1] && this.autoWidth && (t2[1] = s2[1].style, t2[1].top = "1px", t2[1].height = this.h - 2 + "px");
    let e2 = h.frag;
    for (let i2 = 1, h2 = s2.length; i2 !== h2; i2++)
      void 0 !== s2[i2] && (e2.appendChild(s2[i2]), t2[i2] = s2[i2].style);
    let o2 = null !== this.target ? this.target : this.isUI ? this.main.inner : document.body;
    this.ontop ? o2.insertAdjacentElement("afterbegin", s2[0]) : o2.appendChild(s2[0]), s2[0].appendChild(e2), this.rSize(), this.isUI || (this.c[0].style.pointerEvents = "auto", i.add(this));
  }
  addTransition() {
    this.baseH && this.transition && this.isUI && (this.c[0].style.transition = "height " + this.transition + "s ease-out");
  }
  dom(t2, s2, i2, e2, o2) {
    return h.dom(t2, s2, i2, e2, o2);
  }
  setSvg(t2, s2, i2, e2, o2) {
    h.setSvg(t2, s2, i2, e2, o2);
  }
  setCss(t2, s2) {
    h.setCss(t2, s2);
  }
  clamp(t2, s2, i2) {
    return h.clamp(t2, s2, i2);
  }
  getColorRing() {
    return h.colorRing || h.makeColorRing(), h.clone(h.colorRing);
  }
  getJoystick(t2) {
    return h["joystick_" + t2] || h.makeJoystick(t2), h.clone(h["joystick_" + t2]);
  }
  getCircular(t2) {
    return h.circular || h.makeCircular(t2), h.clone(h.circular);
  }
  getKnob(t2) {
    return h.knob || h.makeKnob(t2), h.clone(h.knob);
  }
  getPad2d(t2) {
    return h.pad2d || h.makePad(t2), h.clone(h.pad2d);
  }
  cursor(t2) {
    i.cursor(t2);
  }
  update() {
  }
  reset() {
  }
  content() {
    return this.c[0];
  }
  getDom() {
    return this.c[0];
  }
  uiout() {
    this.lock || this.overEffect && this.s && (this.s[0].background = this.colors.background);
  }
  uiover() {
    this.lock || this.overEffect && this.s && (this.s[0].background = this.colors.backgroundOver);
  }
  rename(t2) {
    void 0 !== this.c[1] && (this.c[1].textContent = t2);
  }
  listen() {
    return this.isListen = i.addListen(this), this;
  }
  listening() {
    null !== this.objectLink && (this.isSend || this.isEdit || this.setValue(this.objectLink[this.objectKey]));
  }
  setValue(t2) {
    this.isNumber ? this.value = this.numValue(t2) : this.value = t2, this.update();
  }
  onChange(t2) {
    if (!this.isSpace)
      return this.callback = t2 || null, this;
  }
  onFinishChange(t2) {
    if (!this.isSpace)
      return this.callback = null, this.endCallback = t2, this;
  }
  onOpen(t2) {
    return this.openCallback = t2, this;
  }
  onClose(t2) {
    return this.closeCallback = t2, this;
  }
  send(t2) {
    (t2 = t2 || this.value) instanceof Array && 1 === t2.length && (t2 = t2[0]), this.isSend = true, null !== this.objectLink && (this.objectLink[this.objectKey] = t2), this.callback && this.callback(t2, this.objectKey), this.isSend = false;
  }
  sendEnd(t2) {
    (t2 = t2 || this.value) instanceof Array && 1 === t2.length && (t2 = t2[0]), this.endCallback && this.endCallback(t2), null !== this.objectLink && (this.objectLink[this.objectKey] = t2);
  }
  dispose() {
    this.isListen && i.removeListen(this), h.clear(this.c[0]), null !== this.target ? null !== this.group ? this.group.clearOne(this) : this.target.removeChild(this.c[0]) : this.isUI ? this.main.clearOne(this) : document.body.removeChild(this.c[0]), this.isUI || i.remove(this), this.c = null, this.s = null, this.callback = null, this.target = null, this.isListen = false;
  }
  clear() {
  }
  getWidth() {
    let t2 = i.getWidth(this);
    t2 && (this.w = t2);
  }
  setSize(t2) {
    if (this.autoWidth)
      if (this.w = t2, this.simple)
        this.sb = this.w - this.sa;
      else {
        let t3 = this.w * (this.p / 100);
        this.sa = Math.floor(t3 + 8), this.sb = Math.floor(this.w - t3 - 16);
      }
  }
  rSize() {
    this.autoWidth && (this.isUI || (this.s[0].width = this.w + "px"), this.simple || (this.s[1].width = this.sa + "px"));
  }
  setTypeNumber(t2) {
    let s2;
    switch (this.isNumber = true, this.value = 0, void 0 !== t2.value && ("string" == typeof t2.value ? this.value = 1 * t2.value : this.value = t2.value), this.min = void 0 === t2.min ? -1 / 0 : t2.min, this.max = void 0 === t2.max ? 1 / 0 : t2.max, this.precision = void 0 === t2.precision ? 2 : t2.precision, this.precision) {
      case 0:
        s2 = 1;
        break;
      case 1:
        s2 = 0.1;
        break;
      case 2:
        s2 = 0.01;
        break;
      case 3:
        s2 = 1e-3;
        break;
      case 4:
        s2 = 1e-4;
        break;
      case 5:
        s2 = 1e-5;
        break;
      case 6:
        s2 = 1e-6;
    }
    this.step = void 0 === t2.step ? s2 : t2.step, this.range = this.max - this.min, this.value = this.numValue(this.value);
  }
  numValue(t2) {
    return this.noNeg && (t2 = Math.abs(t2)), 1 * Math.min(this.max, Math.max(this.min, t2)).toFixed(this.precision);
  }
  handleEvent(t2) {
    if (!this.lock)
      return this.neverlock && (i.lock = false), this[t2.type] ? this[t2.type](t2) : console.error(t2.type, "this type of event no existe !");
  }
  wheel(t2) {
    return false;
  }
  mousedown(t2) {
    return false;
  }
  mousemove(t2) {
    return false;
  }
  mouseup(t2) {
    return false;
  }
  keydown(t2) {
    return false;
  }
  keyup(t2) {
    return false;
  }
  setReferency(t2, s2) {
    this.objectLink = t2, this.objectKey = s2;
  }
  display(t2 = false) {
    this.s[0].visibility = t2 ? "visible" : "hidden";
  }
  open() {
    this.isOpen || (this.isOpen = true, i.needResize = true, this.openCallback && this.openCallback());
  }
  close() {
    this.isOpen && (this.isOpen = false, i.needResize = true, this.closeCallback && this.closeCallback());
  }
  needZone() {
    i.needReZone = true;
  }
  rezone() {
    i.needReZone = true;
  }
  select() {
  }
  unselect() {
  }
  setInput(t2) {
    i.setInput(t2, this);
  }
  upInput(t2, s2) {
    return i.upInput(t2, s2);
  }
  selected(t2) {
    this.isSelect = t2 || false;
  }
};
var l = class extends r {
  constructor(t2 = {}) {
    super(t2), this.value = t2.value || false, this.model = void 0 !== t2.mode ? t2.mode : 0, this.onName = t2.rename || this.txt, t2.onName && (t2.onname = t2.onName), t2.onname && (this.onName = t2.onname), this.inh = t2.inh || Math.floor(0.8 * this.h), this.inw = t2.inw || 36;
    let s2 = this.colors;
    if (0 === this.model) {
      let t3 = Math.floor(0.5 * this.h) - 0.5 * (this.inh - 2);
      this.c[2] = this.dom("div", this.css.basic + "background:" + s2.inputBg + "; height:" + (this.inh - 2) + "px; width:" + this.inw + "px; top:" + t3 + "px; border-radius:10px; border:2px solid " + s2.back), this.c[3] = this.dom("div", this.css.basic + "height:" + (this.inh - 6) + "px; width:16px; top:" + (t3 + 2) + "px; border-radius:10px; background:" + s2.button + ";");
    } else
      this.p = 0, void 0 !== this.c[1] && (this.c[1].textContent = ""), this.c[2] = this.dom("div", this.css.txt + this.css.button + "top:1px; background:" + s2.button + "; height:" + (this.h - 2) + "px; border:" + s2.borderSize + "px solid " + s2.border + "; border-radius:" + this.radius + "px;");
    this.stat = -1, this.init(), this.update();
  }
  mousedown(t2) {
    return this.value = !this.value, this.update(true), this.mousemove(t2);
  }
  mousemove(t2) {
    return this.cursor("pointer"), this.mode(true);
  }
  reset() {
    return this.cursor(), this.mode();
  }
  mode(t2) {
    let s2, i2 = false, e2 = this.colors, h2 = this.s, o2 = this.value;
    if (s2 = t2 ? o2 ? 4 : 3 : o2 ? 2 : 1, this.stat !== s2) {
      if (this.stat = s2, 0 !== this.model) {
        switch (s2) {
          case 1:
            h2[2].color = e2.text, h2[2].background = e2.button;
            break;
          case 2:
            h2[2].color = e2.textSelect, h2[2].background = e2.select;
            break;
          case 3:
            h2[2].color = e2.textOver, h2[2].background = e2.overoff;
            break;
          case 4:
            h2[2].color = e2.textOver, h2[2].background = e2.over;
        }
        this.c[2].innerHTML = o2 ? this.onName : this.name;
      } else {
        switch (s2) {
          case 1:
            h2[2].background = h2[2].borderColor = e2.backoff, h2[3].background = e2.button;
            break;
          case 2:
            h2[2].background = h2[2].borderColor = e2.back, h2[3].background = e2.textOver;
            break;
          case 3:
            h2[2].background = h2[2].borderColor = e2.back, h2[3].background = e2.overoff;
            break;
          case 4:
            h2[2].background = h2[2].borderColor = e2.backoff, h2[3].background = e2.textSelect;
        }
        h2[3].marginLeft = o2 ? "17px" : "2px", this.c[1].textContent = o2 ? this.onName : this.name;
      }
      i2 = true;
    }
    return i2;
  }
  update(t2) {
    this.mode(), t2 && this.send();
  }
  rSize() {
    super.rSize();
    let t2 = this.s, s2 = this.w - 10 - this.inw;
    0 === this.model ? (t2[2].left = s2 + "px", t2[3].left = s2 + "px") : (t2[2].left = this.sa + "px", t2[2].width = this.sb + "px");
  }
};
var a = class extends r {
  constructor(t2 = {}) {
    super(t2), this.value = "", void 0 !== t2.value && (this.value = t2.value), this.values = t2.value || this.txt, t2.values && (this.values = t2.values), t2.values || t2.value || (this.txt = ""), this.onName = t2.onName || null, this.on = false, this.bw = t2.forceWidth || 0, t2.bw && (this.bw = t2.bw), this.space = t2.space || 3, "string" == typeof this.values && (this.values = [this.values]), this.isDown = false, this.neverlock = true, this.res = 0, this.lng = this.values.length, this.tmp = [], this.stat = [];
    let s2, i2 = this.colors;
    for (let t3 = 0; t3 < this.lng; t3++)
      s2 = false, this.values[t3] === this.value && this.isSelectable && (s2 = true), this.c[t3 + 2] = this.dom("div", this.css.txt + this.css.button + "top:1px; height:" + (this.h - 2) + "px; border:" + i2.borderSize + "px solid " + i2.border + "; border-radius:" + this.radius + "px;"), this.c[t3 + 2].style.background = s2 ? i2.select : i2.button, this.c[t3 + 2].style.color = s2 ? i2.textSelect : i2.text, this.c[t3 + 2].innerHTML = this.values[t3], this.stat[t3] = s2 ? 3 : 1;
    "" === this.txt && (this.p = 0), (t2.value || t2.values) && 0 !== this.p || void 0 !== this.c[1] && (this.c[1].textContent = ""), this.init();
  }
  onOff() {
    this.on = !this.on, this.label(this.on ? this.onName : this.value);
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return -1;
    let i2 = this.lng, e2 = this.tmp;
    for (; i2--; )
      if (s2.x > e2[i2][0] && s2.x < e2[i2][2])
        return i2;
    return -1;
  }
  mouseup(t2) {
    return !!this.isDown && (this.isDown = false, -1 !== this.res && (this.value === this.values[this.res] && this.unselectable ? this.value = "" : this.value = this.values[this.res], null !== this.onName && this.onOff(), this.send()), this.mousemove(t2));
  }
  mousedown(t2) {
    return !this.isDown && (this.isDown = true, this.mousemove(t2));
  }
  mousemove(t2) {
    let s2 = false;
    return this.res = this.testZone(t2), -1 !== this.res ? (this.cursor("pointer"), s2 = this.modes(this.isDown ? 3 : 2, this.res)) : s2 = this.reset(), s2;
  }
  modes(t2 = 1, s2 = -1) {
    let i2, e2, h2 = this.lng, o2 = false;
    for (; h2--; )
      e2 = t2, i2 = !!this.isSelectable && this.values[h2] === this.value, h2 === s2 ? i2 && 2 === e2 && (e2 = 3) : (e2 = 1, i2 && (e2 = 4)), o2 = this.mode(e2, h2);
    return o2;
  }
  mode(t2, s2) {
    let i2 = false, e2 = this.colors, h2 = this.s, o2 = s2 + 2;
    if (this.stat[s2] !== t2) {
      switch (this.stat[s2] = t2, t2) {
        case 1:
          h2[o2].color = e2.text, h2[o2].background = e2.button;
          break;
        case 2:
          h2[o2].color = e2.textOver, h2[o2].background = e2.overoff;
          break;
        case 3:
          h2[o2].color = e2.textOver, h2[o2].background = e2.over;
          break;
        case 4:
          h2[o2].color = e2.textSelect, h2[o2].background = e2.select;
      }
      i2 = true;
    }
    return i2;
  }
  reset() {
    return this.res = -1, this.cursor(), this.modes();
  }
  label(t2, s2) {
    s2 = s2 || 2, this.c[s2].textContent = t2;
  }
  switchValues(t2, s2) {
    this.c[t2 + 2].innerHTML = this.values[t2] = s2;
  }
  icon(t2, s2 = 0, i2 = 2) {
    return this.s[i2].padding = s2 + "px 0px", this.c[i2].innerHTML = t2, this;
  }
  rSize() {
    super.rSize();
    let t2 = this.s, s2 = this.sb, i2 = this.sa, e2 = this.lng, h2 = this.colors.sx, o2 = (s2 - h2 * (e2 - 1)) / e2;
    for (this.bw && (o2 = this.bw < o2 ? this.bw : o2, i2 = 0.5 * (this.w - (o2 * e2 + h2 * (e2 - 1)))); e2--; )
      this.tmp[e2] = [i2 + o2 * e2 + h2 * e2, o2], this.tmp[e2][2] = this.tmp[e2][0] + this.tmp[e2][1], t2[e2 + 2].left = this.tmp[e2][0] + "px", t2[e2 + 2].width = this.tmp[e2][1] + "px";
  }
};
var c = class extends r {
  constructor(t2 = {}) {
    super(t2), this.isCyclic = t2.cyclic || false, this.model = t2.stype || 0, void 0 !== t2.mode && (this.model = t2.mode), this.autoWidth = false, this.minw = this.w, this.diam = t2.diam || this.w, this.setTypeNumber(t2), this.twoPi = h.TwoPI, this.pi90 = h.pi90, this.offset = new n(), this.h = t2.h || this.w + 10, this.c[0].style.width = this.w + "px", this.c[0].style.display = "block", void 0 !== this.c[1] && (this.c[1].style.width = "100%", this.c[1].style.justifyContent = "center", this.top = 10, this.h += 10), this.percent = 0, this.cmode = 0;
    let s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txt + "justify-content:center; top:" + (this.h - 20) + "px; width:100%; color:" + s2.text), this.c[3] = this.getCircular(), this.setSvg(this.c[3], "stroke", s2.back, 0), this.setSvg(this.c[3], "d", this.makePath(), 1), this.setSvg(this.c[3], "stroke", s2.text, 1), this.setSvg(this.c[3], "viewBox", "0 0 " + this.diam + " " + this.diam), this.setCss(this.c[3], { width: this.diam, height: this.diam, left: 0, top: this.top }), this.init(), this.update();
  }
  mode(t2) {
    if (this.cmode === t2)
      return false;
    let s2, i2 = this.colors;
    switch (t2) {
      case 0:
        this.s[2].color = i2.text, this.setSvg(this.c[3], "stroke", i2.back, 0), s2 = this.model > 0 ? h.pack(h.lerpColor(h.unpack(h.ColorLuma(i2.text, -0.75)), h.unpack(i2.text), this.percent)) : i2.text, this.setSvg(this.c[3], "stroke", s2, 1);
        break;
      case 1:
        this.s[2].color = i2.textOver, this.setSvg(this.c[3], "stroke", i2.backoff, 0), s2 = this.model > 0 ? h.pack(h.lerpColor(h.unpack(h.ColorLuma(i2.text, -0.75)), h.unpack(i2.text), this.percent)) : i2.textOver, this.setSvg(this.c[3], "stroke", s2, 1);
    }
    return this.cmode = t2, true;
  }
  reset() {
    this.isDown = false;
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.y <= this.c[1].offsetHeight ? "title" : s2.y > this.h - this.c[2].offsetHeight ? "text" : "circular";
  }
  mouseup(t2) {
    return this.isDown = false, this.sendEnd(), this.mode(0);
  }
  mousedown(t2) {
    return this.isDown = true, this.old = this.value, this.oldr = null, this.mousemove(t2), this.mode(1);
  }
  mousemove(t2) {
    if (!this.isDown)
      return;
    let s2 = this.offset;
    if (s2.x = 0.5 * this.w - (t2.clientX - this.zone.x), s2.y = 0.5 * this.diam - (t2.clientY - this.zone.y - this.ytop), this.r = s2.angle() - this.pi90, this.r = (this.r % this.twoPi + this.twoPi) % this.twoPi, null !== this.oldr) {
      let t3 = this.r - this.oldr;
      this.r = Math.abs(t3) > Math.PI ? this.oldr : this.r, t3 > 6 && (this.r = 0), t3 < -6 && (this.r = this.twoPi);
    }
    let i2 = 1 / this.twoPi, e2 = this.r * i2, h2 = this.range * e2 + this.min - this.old;
    (h2 >= this.step || h2 <= this.step) && (h2 = ~~(h2 / this.step), this.value = this.numValue(this.old + h2 * this.step), this.update(true), this.old = this.value, this.oldr = this.r);
  }
  wheel(t2) {
    if ("circular" === this.testZone(t2)) {
      let s2 = this.value - this.step * t2.delta;
      return s2 > this.max ? s2 = this.isCyclic ? this.min : this.max : s2 < this.min && (s2 = this.isCyclic ? this.max : this.min), this.setValue(s2), this.old = s2, this.update(true), true;
    }
    return false;
  }
  makePath() {
    let t2 = 40, s2 = this.percent * this.twoPi - 1e-3, i2 = t2 + t2 * Math.sin(s2) + 24, e2 = t2 - t2 * Math.cos(s2) + 24;
    return "M 64,24 A 40,40 0 " + (s2 > Math.PI ? 1 : 0) + " 1 " + i2 + "," + e2;
  }
  update(t2) {
    if (this.c[2].textContent = this.value, this.percent = (this.value - this.min) / this.range, this.setSvg(this.c[3], "d", this.makePath(), 1), this.model > 0) {
      let t3 = this.colors, s2 = h.pack(h.lerpColor(h.unpack(h.ColorLuma(t3.text, -0.75)), h.unpack(t3.text), this.percent));
      this.setSvg(this.c[3], "stroke", s2, 1);
    }
    t2 && this.send();
  }
};
var d = class extends r {
  constructor(t2 = {}) {
    super(t2), this.ctype = t2.ctype || "hex", this.wfixe = 256, this.cw = this.sb > 256 ? 256 : this.sb, null != t2.cw && (this.cw = t2.cw), this.side = t2.side || "down", this.up = "down" === this.side ? 0 : 1, this.baseH = this.h, this.offset = new n(), this.decal = new n(), this.pp = new n();
    let s2 = this.colors;
    this.c[2] = this.dom("div", `${this.css.txt} ${this.css.middle} top:1px; height:${this.h - 2}px; border-radius:${this.radius}px; text-shadow:none; border:${s2.borderSize}px solid ${s2.border};`), this.c[0].style.display = "block", this.c[3] = this.getColorRing(), this.c[3].style.visibility = "hidden", this.hsl = null, this.value = "#ffffff", void 0 !== t2.value && (t2.value instanceof Array ? this.value = h.rgbToHex(t2.value) : isNaN(t2.value) ? this.value = t2.value : this.value = h.hexToHtml(t2.value)), this.bcolor = null, this.isDown = false, this.fistDown = false, this.notext = t2.notext || false, this.tr = 98, this.tsl = Math.sqrt(3) * this.tr, this.hue = 0, this.d = 256, this.init(), this.setColor(this.value), void 0 !== t2.open && this.open();
  }
  testZone(t2, s2) {
    let i2 = this.local;
    return -1 === i2.x && -1 === i2.y ? "" : this.up && this.isOpen ? i2.y > this.wfixe ? "title" : "color" : i2.y < this.baseH + 2 ? "title" : this.isOpen ? "color" : void 0;
  }
  mouseup(t2) {
    this.isDown = false, this.d = 256;
  }
  mousedown(t2) {
    let s2 = this.testZone(t2.clientX, t2.clientY);
    if ("title" === s2)
      return this.isOpen ? this.close() : this.open(), true;
    "color" === s2 && (this.isDown = true, this.fistDown = true, this.mousemove(t2));
  }
  mousemove(t2) {
    let s2, i2, e2, o2, n2, r2, l2, a2, c2, d2 = this.testZone(t2.clientX, t2.clientY), u2 = h;
    if ("title" === d2 && this.cursor("pointer"), "color" === d2 && (s2 = this.offset, s2.x = t2.clientX - (this.zone.x + this.decal.x + this.mid), s2.y = t2.clientY - (this.zone.y + this.decal.y + this.mid) - this.ytop, i2 = s2.length() * this.ratio, c2 = s2.angle(), c2 < 0 && (c2 += 2 * u2.PI), i2 < 128 ? this.cursor("crosshair") : this.isDown || this.cursor(), this.isDown && (this.fistDown && (this.d = i2, this.fistDown = false), this.d < 128)))
      if (this.d > this.tr)
        e2 = (c2 + u2.pi90) / u2.TwoPI, this.hue = (e2 + 1) % 1, this.setHSL([(e2 + 1) % 1, this.hsl[1], this.hsl[2]]);
      else {
        l2 = s2.x * this.ratio, a2 = s2.y * this.ratio;
        let t3 = this.hue * u2.TwoPI + u2.PI;
        t3 < 0 && (t3 += 2 * u2.PI), r2 = Math.atan2(-a2, l2), r2 < 0 && (r2 += 2 * u2.PI);
        let i3 = (r2 + u2.pi90 + u2.TwoPI + t3) % u2.TwoPI, e3 = i3 % (2 / 3 * u2.PI) - u2.pi60, h2 = 0.5 * this.tr, c3 = Math.tan(e3) * h2, d3 = Math.sqrt(l2 * l2 + a2 * a2), p2 = Math.sqrt(h2 * h2 + c3 * c3);
        if (d3 > p2) {
          let s3 = Math.tan(e3) * d3, o3 = Math.atan(s3 / p2);
          o3 > u2.pi60 ? o3 = u2.pi60 : o3 < -u2.pi60 && (o3 = -u2.pi60), r2 += o3 - e3, i3 = (r2 + u2.pi90 + u2.TwoPI + t3) % u2.TwoPI, e3 = i3 % (2 / 3 * u2.PI) - u2.pi60, c3 = Math.tan(e3) * h2, d3 = p2 = Math.sqrt(h2 * h2 + c3 * c3);
        }
        n2 = Math.sin(i3) * d3 / this.tsl + 0.5;
        let m2 = 1 - 2 * Math.abs(n2 - 0.5);
        o2 = (Math.cos(i3) * d3 + this.tr / 2) / (1.5 * this.tr) / m2, o2 = u2.clamp(o2, 0, 1), this.setHSL([this.hsl[0], o2, n2]);
      }
  }
  setHeight() {
    this.h = this.isOpen ? this.wfixe + this.baseH + 5 : this.baseH, this.s[0].height = this.h + "px", this.zone.h = this.h;
  }
  parentHeight(t2) {
    null !== this.group ? this.group.calc(t2) : this.isUI && this.main.calc(t2);
  }
  open() {
    super.open(), this.setHeight(), this.up && (this.zone.y -= this.wfixe + 5);
    let t2 = this.h - this.baseH;
    this.s[3].visibility = "visible", this.parentHeight(t2);
  }
  close() {
    super.close(), this.up && (this.zone.y += this.wfixe + 5);
    let t2 = this.h - this.baseH;
    this.setHeight(), this.s[3].visibility = "hidden", this.parentHeight(-t2);
  }
  update(t2) {
    let s2 = h.rgbToHex(h.hslToRgb([this.hsl[0], 1, 0.5]));
    this.moveMarkers(), this.value = this.bcolor, this.setSvg(this.c[3], "fill", s2, 2, 0), this.s[2].background = this.bcolor, this.notext || (this.c[2].textContent = h.htmlToHex(this.bcolor)), this.invert = h.findDeepInver(this.rgb), this.s[2].color = this.invert ? "#fff" : "#000", t2 && ("array" === this.ctype && this.send(this.rgb), "rgb" === this.ctype && this.send(h.htmlRgb(this.rgb)), "hex" === this.ctype && this.send(h.htmlToHex(this.value)), "html" === this.ctype && this.send());
  }
  setValue(t2) {
    t2 instanceof Array ? this.value = h.rgbToHex(t2) : isNaN(t2) ? this.value = t2 : this.value = h.hexToHtml(t2), this.setColor(this.value), this.update();
  }
  setColor(t2) {
    let s2 = h.unpack(t2);
    return this.bcolor !== t2 && s2 && (this.bcolor = t2, this.rgb = s2, this.hsl = h.rgbToHsl(this.rgb), this.hue = this.hsl[0], this.update()), this;
  }
  setHSL(t2) {
    return this.hsl = t2, this.rgb = h.hslToRgb(t2), this.bcolor = h.rgbToHex(this.rgb), this.update(true), this;
  }
  moveMarkers() {
    let t2 = this.pp, s2 = h;
    this.invert;
    let i2 = this.hsl[0] * s2.TwoPI, e2 = 2 / 3 * s2.PI, o2 = this.tr, n2 = this.hsl[0], r2 = this.hsl[1], l2 = this.hsl[2], a2 = (i2 - s2.pi90) * s2.todeg;
    n2 = -i2 + s2.pi90;
    let c2 = Math.cos(n2) * o2, d2 = -Math.sin(n2) * o2, u2 = Math.cos(n2 - e2) * o2, p2 = -Math.sin(n2 - e2) * o2, m2 = Math.cos(n2 + e2) * o2, g2 = -Math.sin(n2 + e2) * o2, x2 = (u2 + m2) / 2, v2 = (p2 + g2) / 2;
    i2 = (1 - 2 * Math.abs(l2 - 0.5)) * r2;
    let b2 = u2 + (m2 - u2) * l2 + (c2 - x2) * i2, f2 = p2 + (g2 - p2) * l2 + (d2 - v2) * i2;
    t2.set(b2, f2).addScalar(128), this.setSvg(this.c[3], "transform", "rotate(" + a2 + " )", 2), this.setSvg(this.c[3], "cx", t2.x, 3), this.setSvg(this.c[3], "cy", t2.y, 3), this.setSvg(this.c[3], "stroke", this.invert ? "#fff" : "#000", 2, 3), this.setSvg(this.c[3], "stroke", this.invert ? "#fff" : "#000", 3), this.setSvg(this.c[3], "fill", this.bcolor, 3);
  }
  rSize() {
    super.rSize();
    let t2 = this.s;
    t2[2].width = this.sb + "px", t2[2].left = this.sa + "px", this.cw = this.sb > 256 ? 256 : this.sb, this.rSizeColor(this.cw), this.decal.x = Math.floor(0.5 * (this.w - this.wfixe));
  }
  rSizeColor(t2) {
    if (t2 === this.wfixe)
      return;
    this.wfixe = t2;
    let s2 = this.s;
    this.decal.y = "up" === this.side ? 2 : this.baseH + 2, this.mid = Math.floor(0.5 * this.wfixe), this.setSvg(this.c[3], "viewBox", "0 0 " + this.wfixe + " " + this.wfixe), s2[3].width = this.wfixe + "px", s2[3].height = this.wfixe + "px", s2[3].top = this.decal.y + "px", this.ratio = 256 / this.wfixe, this.square = 1 / (this.wfixe / 256 * 60), this.setHeight();
  }
};
var u = class extends r {
  constructor(t2 = {}) {
    super(t2), this.round = Math.round, this.baseH = this.h, this.hplus = t2.hplus || 50, this.res = t2.res || 40, this.l = 1, this.precision = t2.precision || 0, this.custom = t2.custom || false, this.names = t2.names || ["FPS", "MS"];
    let s2 = t2.cc || ["220,220,220", "255,255,0"];
    this.adding = t2.adding || false, this.range = t2.range || [165, 100, 100], this.alpha = t2.alpha || 0.25, this.values = [], this.points = [], this.textDisplay = [], this.custom || (this.now = i.getTime(), this.startTime = 0, this.prevTime = 0, this.frames = 0, this.ms = 0, this.fps = 0, this.mem = 0, this.mm = 0, this.isMem = !(!self.performance || !self.performance.memory), this.isMem && (this.names.push("MEM"), s2.push("0,255,255")), this.txt = t2.name || "Fps");
    let e2 = Math.floor(0.5 * this.h) - 3;
    const h2 = this.colors;
    this.c[1].textContent = this.txt, this.c[0].style.cursor = "pointer", this.c[0].style.pointerEvents = "auto";
    let o2 = "display:none; left:10px; top:" + this.h + "px; height:" + (this.hplus - 8) + "px; box-sizing:border-box; background: rgba(0, 0, 0, 0.2); border:1px solid " + h2.border + ";";
    0 !== this.radius && (o2 += "border-radius:" + this.radius + "px;"), this.c[2] = this.dom("path", this.css.basic + o2, {}), this.c[2].setAttribute("viewBox", "0 0 " + this.res + " 50"), this.c[2].setAttribute("height", "100%"), this.c[2].setAttribute("width", "100%"), this.c[2].setAttribute("preserveAspectRatio", "none"), this.c[3] = this.dom("path", this.css.basic + "position:absolute; width:6px; height:6px; left:0; top:" + e2 + "px;", { d: this.svgs.g1, fill: h2.text, stroke: "none" }), this.c[4] = this.dom("div", this.css.txt + "position:absolute; left:10px; top:" + (this.h + 2) + "px; display:none; width:100%; text-align:center;"), t2.bottomLine && (this.c[4] = this.dom("div", this.css.basic + "width:100%; bottom:0px; height:1px; background: rgba(255, 255, 255, 0.2);")), this.isShow = false;
    let n2 = this.s;
    n2[1].lineHeight = this.h - 4, n2[1].color = h2.text, 0 !== this.radius && (n2[0].borderRadius = this.radius + "px"), "none" !== this.colors.gborder && (n2[0].border = "1px solid " + h2.gborder);
    let r2 = 0;
    for (r2 = 0; r2 < this.names.length; r2++) {
      let t3 = [], i2 = this.res + 1;
      for (; i2--; )
        t3.push(50);
      this.range[r2] = 1 / this.range[r2] * 49, this.points.push(t3), this.values.push(0), this.textDisplay.push("<span style='color:rgb(" + s2[r2] + ")'> " + this.names[r2] + " ");
    }
    for (r2 = this.names.length; r2--; )
      this.dom("path", null, { fill: "rgba(" + s2[r2] + "," + this.alpha + ")", "stroke-width": 1, stroke: "rgba(" + s2[r2] + ",1)", "vector-effect": "non-scaling-stroke" }, this.c[2]);
    this.init();
  }
  mousedown(t2) {
    this.isShow ? this.close() : this.open();
  }
  tick(t2) {
    this.values = t2, this.isShow && (this.drawGraph(), this.upText());
  }
  makePath(t2) {
    let s2 = "";
    s2 += "M -1 50";
    for (let i2 = 0; i2 < this.res + 1; i2++)
      s2 += " L " + i2 + " " + t2[i2];
    return s2 += " L " + (this.res + 1) + " 50", s2;
  }
  upText(t2) {
    let s2 = t2 || this.values, i2 = "";
    for (let t3 = 0, e2 = this.names.length; t3 < e2; t3++)
      i2 += this.textDisplay[t3] + s2[t3].toFixed(this.precision) + "</span>";
    this.c[4].innerHTML = i2;
  }
  drawGraph() {
    let t2, s2 = this.c[2], i2 = this.names.length, e2 = 0, h2 = 0;
    for (; i2--; )
      t2 = this.adding ? (this.values[h2] + e2) * this.range[h2] : this.values[h2] * this.range[h2], this.points[h2].shift(), this.points[h2].push(50 - t2), this.setSvg(s2, "d", this.makePath(this.points[h2]), i2 + 1), e2 += this.values[h2], h2++;
  }
  open() {
    super.open(), this.h = this.hplus + this.baseH, this.setSvg(this.c[3], "d", this.svgs.g2), null !== this.group ? this.group.calc(this.hplus) : this.isUI && this.main.calc(this.hplus), this.s[0].height = this.h + "px", this.s[2].display = "block", this.s[4].display = "block", this.isShow = true, this.custom || i.addListen(this);
  }
  close() {
    super.close(), this.h = this.baseH, this.setSvg(this.c[3], "d", this.svgs.g1), null !== this.group ? this.group.calc(-this.hplus) : this.isUI && this.main.calc(-this.hplus), this.s[0].height = this.h + "px", this.s[2].display = "none", this.s[4].display = "none", this.isShow = false, this.custom || i.removeListen(this), this.c[4].innerHTML = "";
  }
  begin() {
    this.startTime = this.now();
  }
  end() {
    let t2 = this.now();
    if (this.ms = t2 - this.startTime, this.frames++, t2 > this.prevTime + 1e3 && (this.fps = this.round(1e3 * this.frames / (t2 - this.prevTime)), this.prevTime = t2, this.frames = 0, this.isMem)) {
      let t3 = performance.memory.usedJSHeapSize, s2 = performance.memory.jsHeapSizeLimit;
      this.mem = this.round(954e-9 * t3), this.mm = t3 / s2;
    }
    return this.values = [this.fps, this.ms, this.mm], this.drawGraph(), this.upText([this.fps, this.ms, this.mem]), t2;
  }
  listening() {
    this.custom || (this.startTime = this.end());
  }
  rSize() {
    let t2 = this.s, s2 = this.w;
    t2[3].left = this.sa + this.sb - 6 + "px", t2[0].width = s2 + "px", t2[1].width = s2 + "px", t2[2].left = "10px", t2[2].width = s2 - 20 + "px", t2[4].width = s2 - 20 + "px";
  }
};
var p = class extends r {
  constructor(t2 = {}) {
    super(t2), this.value = void 0 !== t2.value ? t2.value : [0, 0, 0], this.lng = this.value.length, this.precision = void 0 !== t2.precision ? t2.precision : 2, this.multiplicator = t2.multiplicator || 1, this.neg = t2.neg || false, this.line = void 0 === t2.line || t2.line, this.autoWidth = void 0 === t2.autoWidth || t2.autoWidth, this.isNumber = false, this.isDown = false, this.h = t2.h || 138, this.rh = this.h - 10, this.top = 0, this.c[0].style.width = this.w + "px", void 0 !== this.c[1] && (this.c[1].style.width = this.w + "px", this.autoWidth || (this.c[1].style.width = "100%", this.c[1].style.justifyContent = "center"), this.top = 10, this.h += 10), this.gh = this.rh - 28, this.gw = this.w - 28, this.c[2] = this.dom("div", this.css.txt + "display:block; text-align:center; padding:0px 0px; top:" + (this.h - 20) + "px; left:14px; width:" + this.gw + "px;  color:" + this.colors.text), this.c[2].innerHTML = this.valueToHtml();
    let s2 = this.dom("svg", this.css.basic, { viewBox: "0 0 " + this.w + " " + this.rh, width: this.w, height: this.rh, preserveAspectRatio: "none" });
    this.setCss(s2, { width: this.w, height: this.rh, left: 0, top: this.top }), this.dom("path", "", { d: "", stroke: this.colors.text, "stroke-width": 2, fill: "none", "stroke-linecap": "butt" }, s2), this.dom("rect", "", { x: 10, y: 10, width: this.gw + 8, height: this.gh + 8, stroke: "rgba(0,0,0,0.3)", "stroke-width": 1, fill: "none" }, s2), this.iw = (this.gw - 4 * (this.lng - 1)) / this.lng;
    let i2 = [];
    this.cMode = [], this.v = [];
    for (let t3 = 0; t3 < this.lng; t3++)
      i2[t3] = [14 + t3 * this.iw + 4 * t3, this.iw], i2[t3][2] = i2[t3][0] + i2[t3][1], this.cMode[t3] = 0, this.neg ? this.v[t3] = 0.5 * (1 + this.value[t3] / this.multiplicator) : this.v[t3] = this.value[t3] / this.multiplicator, this.dom("rect", "", { x: i2[t3][0], y: 14, width: i2[t3][1], height: 1, fill: this.colors.text, "fill-opacity": 0.3 }, s2);
    this.tmp = i2, this.c[3] = s2, this.init(), void 0 !== this.c[1] && (this.c[1].style.top = "0px", this.c[1].style.height = "20px", this.s[1].lineHeight = "15px"), this.update(false);
  }
  setValue(t2) {
    this.value = t2, this.lng = this.value.length;
    for (var s2 = 0; s2 < this.lng; s2++)
      this.neg ? this.v[s2] = 0.5 * (1 + t2[s2] / this.multiplicator) : this.v[s2] = t2[s2] / this.multiplicator;
    this.update();
  }
  valueToHtml() {
    let t2 = this.lng, s2 = 0, i2 = '<table style="width:100%;"><tr>', e2 = "width:" + 100 / this.lng + "%;";
    for (; t2--; )
      s2 === this.lng - 1 ? i2 += "<td style=" + e2 + ">" + this.value[s2] + "</td></tr></table>" : i2 += "<td style=" + e2 + ">" + this.value[s2] + "</td>", s2++;
    return i2;
  }
  updateSVG() {
    this.line && this.setSvg(this.c[3], "d", this.makePath(), 0);
    for (let t2 = 0; t2 < this.lng; t2++)
      this.setSvg(this.c[3], "height", this.v[t2] * this.gh, t2 + 2), this.setSvg(this.c[3], "y", this.gh - this.v[t2] * this.gh + 14, t2 + 2), this.neg ? this.value[t2] = 1 * ((2 * this.v[t2] - 1) * this.multiplicator).toFixed(this.precision) : this.value[t2] = 1 * (this.v[t2] * this.multiplicator).toFixed(this.precision);
    this.c[2].innerHTML = this.valueToHtml();
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return "";
    let i2 = this.lng, e2 = this.tmp;
    if (s2.y > this.top && s2.y < this.h - 20) {
      for (; i2--; )
        if (s2.x > e2[i2][0] && s2.x < e2[i2][2])
          return i2;
    }
    return "";
  }
  mode(t2, s2) {
    if (t2 === this.cMode[s2])
      return false;
    let i2;
    switch (t2) {
      case 0:
        i2 = 0.3;
        break;
      case 1:
        i2 = 0.6;
        break;
      case 2:
        i2 = 1;
    }
    return this.reset(), this.setSvg(this.c[3], "fill-opacity", i2, s2 + 2), this.cMode[s2] = t2, true;
  }
  reset() {
    let t2 = false, s2 = this.lng;
    for (; s2--; )
      0 !== this.cMode[s2] && (this.cMode[s2] = 0, this.setSvg(this.c[3], "fill-opacity", 0.3, s2 + 2), t2 = true);
    return t2;
  }
  mouseup(t2) {
    if (this.isDown = false, -1 !== this.current)
      return this.reset();
  }
  mousedown(t2) {
    return this.isDown = true, this.mousemove(t2);
  }
  mousemove(t2) {
    let s2 = false, i2 = this.testZone(t2);
    return "" === i2 ? s2 = this.reset() : (s2 = this.mode(this.isDown ? 2 : 1, i2), this.isDown && (this.v[i2] = this.clamp(1 - (t2.clientY - this.zone.y - this.ytop - 10) / this.gh, 0, 1), this.update(true))), s2;
  }
  update(t2) {
    this.updateSVG(), t2 && this.send();
  }
  makePath() {
    let t2, s2, i2, e2, h2, o2, n2 = "";
    for (let r2 = 0; r2 < this.lng; r2++)
      t2 = this.gh - this.v[r2] * this.gh + 14, s2 = 14 + r2 * this.iw + 4 * r2, e2 = s2 + 0.5 * this.iw, i2 = s2 + this.iw, n2 += 0 === r2 ? "M " + s2 + " " + t2 + " T " + e2 + " " + t2 : " C " + h2 + " " + o2 + "," + s2 + " " + t2 + "," + e2 + " " + t2, r2 === this.lng - 1 && (n2 += " T " + i2 + " " + t2), h2 = i2, o2 = t2;
    return n2;
  }
  rSize() {
    super.rSize();
    let t2 = this.s;
    void 0 !== this.c[1] && (t2[1].width = this.w + "px"), t2[3].width = this.w + "px";
    let s2 = this.w - 28, i2 = (s2 - 4 * (this.lng - 1)) / this.lng, e2 = [];
    t2[2].width = s2 + "px";
    for (let t3 = 0; t3 < this.lng; t3++)
      e2[t3] = [14 + t3 * i2 + 4 * t3, i2], e2[t3][2] = e2[t3][0] + e2[t3][1];
    this.tmp = e2;
  }
};
var m = class extends r {
  constructor(t2 = {}) {
    t2.isSpace = true, t2.margin = 0, t2.h || (t2.h = 10), super(t2), this.init();
  }
};
var g = class extends r {
  constructor(t2 = {}) {
    super(t2), this.isGroup = true, this.ADD = t2.add, this.autoHeight = true, this.uis = [], this.current = -1, this.proto = null, this.isEmpty = true, this.decal = t2.group ? 8 : 0, this.baseH = this.h, this.spaceY = new m({ h: this.margin });
    let s2 = Math.floor(0.5 * this.h) - 3;
    const i2 = this.colors;
    this.useFlex = true;
    let e2 = this.useFlex ? "display:flex; flex-flow: row wrap;" : "";
    this.c[2] = this.dom("div", this.css.basic + e2 + "width:100%; left:0;  overflow:hidden; top:" + this.h + "px"), this.c[3] = this.dom("path", this.css.basic + "position:absolute; width:6px; height:6px; left:0; top:" + s2 + "px;", { d: this.svgs.g1, fill: i2.text, stroke: "none" });
    let h2 = 0 === this.mtop ? this.margin : this.mtop;
    this.c[4] = this.dom("div", this.css.basic + "width:100%; left:0; height:" + (h2 + 1) + "px; top:" + (this.h - 1) + "px; background:none;"), this.s, this.c[1].name = "group", this.init(), this.setBG(t2.bg), t2.open && this.open();
  }
  setBG(t2) {
    const s2 = this.colors, i2 = this.s;
    void 0 !== t2 && (s2.groups = t2), "none" === s2.groups && (s2.groups = s2.background), s2.background = "none", i2[0].background = "none", i2[1].background = s2.groups, i2[2].background = s2.groups, "none" !== s2.gborder && (i2[1].border = s2.borderSize + "px solid " + s2.gborder), 0 !== this.radius && (i2[1].borderRadius = this.radius + "px", i2[2].borderRadius = this.radius + "px");
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return "";
    let i2 = "";
    return s2.y < this.baseH + this.margin ? i2 = "title" : this.isOpen && (i2 = "content"), i2;
  }
  clearTarget() {
    return -1 !== this.current && (this.proto.s && (this.proto.uiout(), this.proto.reset()), this.proto = null, this.current = -1, this.cursor(), true);
  }
  reset() {
    this.clearTarget();
  }
  handleEvent(t2) {
    let s2 = t2.type, e2 = false, h2 = false, o2 = this.testZone(t2);
    if (o2) {
      switch (o2) {
        case "content":
          i.isMobile && "mousedown" === s2 && this.getNext(t2, e2), this.proto && (h2 = this.proto.handleEvent(t2)), i.lock || this.getNext(t2, e2);
          break;
        case "title":
          this.cursor("pointer"), "mousedown" === s2 && (this.isOpen ? this.close() : this.open());
      }
      return this.isDown && (e2 = true), h2 && (e2 = true), e2;
    }
  }
  getNext(t2, s2) {
    let e2 = i.findTarget(this.uis, t2);
    e2 !== this.current && (this.clearTarget(), this.current = e2), -1 !== e2 && (this.proto = this.uis[this.current], this.proto.uiover());
  }
  add() {
    let t2 = arguments;
    "object" == typeof t2[1] ? (t2[1].isUI = this.isUI, t2[1].target = this.c[2], t2[1].main = this.main, t2[1].group = this) : "string" == typeof arguments[1] && (void 0 === t2[2] ? [].push.call(t2, { isUI: true, target: this.c[2], main: this.main }) : (t2[2].isUI = true, t2[2].target = this.c[2], t2[2].main = this.main, t2[2].group = this));
    let s2 = this.ADD.apply(this, t2);
    return s2.isGroup && (s2.dx = 8), i.forceZone = true, this.uis.push(s2), this.isEmpty = false, s2;
  }
  remove(t2) {
    t2.dispose && t2.dispose();
  }
  dispose() {
    this.clear(), this.isUI && this.main.calc(), super.dispose();
  }
  clear() {
    this.empty();
  }
  empty() {
    this.close();
    let t2, s2 = this.uis.length;
    for (; s2--; )
      t2 = this.uis.pop(), this.c[2].removeChild(t2.c[0]), t2.clear(true);
    this.isEmpty = true, this.h = this.baseH;
  }
  clearOne(t2) {
    let s2 = this.uis.indexOf(t2);
    -1 !== s2 && (this.calc(-(this.uis[s2].h + this.margin)), this.c[2].removeChild(this.uis[s2].c[0]), this.uis.splice(s2, 1), 0 === this.uis.length && (this.isEmpty = true, this.close()));
  }
  open() {
    super.open(), this.setSvg(this.c[3], "d", this.svgs.g2), this.rSizeContent();
    const t2 = this.s, s2 = this.colors;
    t2[2].top = this.h + this.mtop + "px", t2[4].background = s2.groups, this.radius && (t2[1].borderRadius = "0px", t2[2].borderRadius = "0px", t2[1].borderTopLeftRadius = this.radius + "px", t2[1].borderTopRightRadius = this.radius + "px", t2[2].borderBottomLeftRadius = this.radius + "px", t2[2].borderBottomRightRadius = this.radius + "px"), "none" !== s2.gborder && (t2[4].borderLeft = s2.borderSize + "px solid " + s2.gborder, t2[4].borderRight = s2.borderSize + "px solid " + s2.gborder, t2[2].border = s2.borderSize + "px solid " + s2.gborder, t2[2].borderTop = "none", t2[1].borderBottom = s2.borderSize + "px solid rgba(0,0,0,0)"), this.parentHeight();
  }
  close() {
    super.close(), this.setSvg(this.c[3], "d", this.svgs.g1), this.h = this.baseH;
    const t2 = this.s, s2 = this.colors;
    t2[0].height = this.h + "px", t2[2].top = this.h + this.mtop + "px", t2[4].background = "none", "none" !== s2.gborder && (t2[4].border = "none", t2[2].border = "none", t2[1].border = s2.borderSize + "px solid " + s2.gborder), this.radius && (t2[1].borderRadius = this.radius + "px"), this.parentHeight();
  }
  calcUis() {
    !this.isOpen || this.isEmpty ? this.h = this.baseH : this.h = i.calcUis([...this.uis, this.spaceY], this.zone, this.zone.y + this.baseH + this.margin, true) + this.baseH, this.s[0].height = this.h + "px", this.s[2].height = this.h - this.baseH + "px";
  }
  parentHeight(t2) {
    null !== this.group ? this.group.calc(t2) : this.isUI && this.main.calc(t2);
  }
  calc(t2) {
    this.isOpen && (this.isUI ? this.main.calc() : this.calcUis(), this.s[0].height = this.h + "px", this.s[2].height = this.h + "px");
  }
  rSizeContent() {
    let t2 = this.uis.length;
    for (; t2--; )
      this.uis[t2].setSize(this.w), this.uis[t2].rSize();
  }
  rSize() {
    super.rSize();
    let t2 = this.s;
    this.w = this.w - this.decal, t2[3].left = this.sa + this.sb - 6 + "px", t2[1].width = this.w + "px", t2[2].width = this.w + "px", t2[1].left = this.decal + "px", t2[2].left = this.decal + "px", this.isOpen && this.rSizeContent();
  }
};
var x = class extends r {
  constructor(t2 = {}) {
    super(t2), this.autoWidth = false, this.value = [0, 0], this.minw = this.w, this.diam = t2.diam || this.w, this.joyType = "analogique", this.model = void 0 !== t2.mode ? t2.mode : 0, this.precision = t2.precision || 2, this.multiplicator = t2.multiplicator || 1, this.pos = new n(), this.tmp = new n(), this.interval = null, this.c[0].style.display = "block", this.haveText = void 0 === t2.text || t2.text, this.distance = 0.5 * this.diam * 0.25, this.h = t2.h || this.w + (this.haveText ? 10 : 0), this.c[0].style.width = this.w + "px", void 0 !== this.c[1] && (this.c[1].style.width = "100%", this.c[1].style.justifyContent = "center", this.top = 10, this.h += 10);
    let s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txt + "justify-content:center; top:" + (this.h - 20) + "px; width:100%; color:" + s2.text), this.c[2].textContent = this.haveText ? this.value : "", this.c[3] = this.getJoystick(this.model), this.setSvg(this.c[3], "viewBox", "0 0 " + this.diam + " " + this.diam), this.setCss(this.c[3], { width: this.diam, height: this.diam, left: 0, top: this.top }), this.mode(0), this.ratio = 128 / this.w, this.init(), this.update(false);
  }
  mode(t2) {
    let s2 = this.colors;
    switch (t2) {
      case 0:
        0 === this.model ? (this.setSvg(this.c[3], "fill", "url(#gradIn)", 4), this.setSvg(this.c[3], "stroke", "#000", 4)) : (this.setSvg(this.c[3], "stroke", s2.joyOut, 2), this.setSvg(this.c[3], "stroke", s2.joyOut, 4), this.setSvg(this.c[3], "fill", "none", 4));
        break;
      case 1:
        0 === this.model ? (this.setSvg(this.c[3], "fill", "url(#gradIn2)", 4), this.setSvg(this.c[3], "stroke", "rgba(0,0,0,0)", 4)) : (this.setSvg(this.c[3], "stroke", s2.joyOver, 2), this.setSvg(this.c[3], "stroke", s2.joySelect, 4), this.setSvg(this.c[3], "fill", s2.joyOver, 4));
    }
  }
  addInterval() {
    null !== this.interval && this.stopInterval(), this.pos.isZero() || (this.interval = setInterval((function() {
      this.update();
    }).bind(this), 10));
  }
  stopInterval() {
    null !== this.interval && (clearInterval(this.interval), this.interval = null);
  }
  reset() {
    this.addInterval(), this.mode(0);
  }
  mouseup(t2) {
    this.addInterval(), this.isDown = false;
  }
  mousedown(t2) {
    this.isDown = true, this.mousemove(t2), this.mode(2);
  }
  mousemove(t2) {
    if (this.mode(1), !this.isDown)
      return;
    if (this.tmp.x = 0.5 * this.w - (t2.clientX - this.zone.x), this.tmp.y = 0.5 * this.diam - (t2.clientY - this.zone.y - this.ytop), this.tmp.length() > this.distance) {
      let t3 = Math.atan2(this.tmp.x, this.tmp.y);
      this.tmp.x = Math.sin(t3) * this.distance, this.tmp.y = Math.cos(t3) * this.distance;
    }
    this.pos.copy(this.tmp).divideScalar(this.distance).negate(), this.update();
  }
  setValue(t2) {
    void 0 === t2 && (t2 = [0, 0]), this.pos.set(t2[0] || 0, t2[1] || 0), this.updateSVG();
  }
  update(t2) {
    void 0 === t2 && (t2 = true), null !== this.interval && (this.isDown || (this.pos.lerp(null, 0.3), this.pos.x = Math.abs(this.pos.x) < 0.01 ? 0 : this.pos.x, this.pos.y = Math.abs(this.pos.y) < 0.01 ? 0 : this.pos.y, this.isUI && this.main.isCanvas && this.main.draw())), this.updateSVG(), t2 && this.send(), this.pos.isZero() && this.stopInterval();
  }
  updateSVG() {
    let t2 = 0.5 * this.diam - -this.pos.x * this.distance, s2 = 0.5 * this.diam - -this.pos.y * this.distance;
    if (0 === this.model) {
      let i2 = t2 + 5 * this.pos.x + 5, e2 = s2 + 5 * this.pos.y + 10;
      this.setSvg(this.c[3], "cx", i2 * this.ratio, 3), this.setSvg(this.c[3], "cy", e2 * this.ratio, 3);
    } else
      this.setSvg(this.c[3], "cx", t2 * this.ratio, 3), this.setSvg(this.c[3], "cy", s2 * this.ratio, 3);
    this.setSvg(this.c[3], "cx", t2 * this.ratio, 4), this.setSvg(this.c[3], "cy", s2 * this.ratio, 4), this.value[0] = 1 * (this.pos.x * this.multiplicator).toFixed(this.precision), this.value[1] = 1 * (this.pos.y * this.multiplicator).toFixed(this.precision), this.haveText && (this.c[2].textContent = this.value);
  }
  clear() {
    this.stopInterval(), super.clear();
  }
};
var v = class extends r {
  constructor(t2 = {}) {
    super(t2), this.isCyclic = t2.cyclic || false, this.model = t2.stype || 0, void 0 !== t2.mode && (this.model = t2.mode), this.autoWidth = false, this.setTypeNumber(t2), this.minw = this.w, this.diam = t2.diam || this.w, this.mPI = 0.8 * Math.PI, this.toDeg = 180 / Math.PI, this.cirRange = 2 * this.mPI, this.offset = new n(), this.h = t2.h || this.w + 10, this.c[0].style.width = this.w + "px", this.c[0].style.display = "block", void 0 !== this.c[1] && (this.c[1].style.width = "100%", this.c[1].style.justifyContent = "center", this.top = 10, this.h += 10), this.percent = 0, this.cmode = 0;
    let s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txt + "justify-content:center; top:" + (this.h - 20) + "px; width:100%; color:" + s2.text), this.c[3] = this.getKnob(), this.setSvg(this.c[3], "fill", s2.button, 0), this.setSvg(this.c[3], "stroke", s2.text, 1), this.setSvg(this.c[3], "stroke", s2.text, 3), this.setSvg(this.c[3], "d", this.makeGrad(), 3), this.setSvg(this.c[3], "viewBox", "0 0 " + this.diam + " " + this.diam), this.setCss(this.c[3], { width: this.diam, height: this.diam, left: 0, top: this.top }), this.model > 0 && (h.dom("path", "", { d: "", stroke: s2.text, "stroke-width": 2, fill: "none", "stroke-linecap": "round" }, this.c[3]), 2 == this.model && (h.addSVGGlowEffect(), this.setSvg(this.c[3], "style", 'filter: url("#UILGlow");', 4))), this.r = 0, this.init(), this.update();
  }
  mode(t2) {
    let s2 = this.colors;
    if (this.cmode === t2)
      return false;
    switch (t2) {
      case 0:
        this.s[2].color = s2.text, this.setSvg(this.c[3], "fill", s2.button, 0), this.setSvg(this.c[3], "stroke", s2.text, 1);
        break;
      case 1:
        this.s[2].color = s2.textOver, this.setSvg(this.c[3], "fill", s2.select, 0), this.setSvg(this.c[3], "stroke", s2.textOver, 1);
    }
    return this.cmode = t2, true;
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.y <= this.c[1].offsetHeight ? "title" : s2.y > this.h - this.c[2].offsetHeight ? "text" : "knob";
  }
  mouseup(t2) {
    return this.isDown = false, this.sendEnd(), this.mode(0);
  }
  mousedown(t2) {
    return this.isDown = true, this.old = this.value, this.oldr = null, this.mousemove(t2), this.mode(1);
  }
  mousemove(t2) {
    if (!this.isDown)
      return;
    let s2 = this.offset;
    s2.x = 0.5 * this.w - (t2.clientX - this.zone.x), s2.y = 0.5 * this.diam - (t2.clientY - this.zone.y - this.ytop), this.r = -Math.atan2(s2.x, s2.y), null !== this.oldr && (this.r = Math.abs(this.r - this.oldr) > Math.PI ? this.oldr : this.r), this.r = this.r > this.mPI ? this.mPI : this.r, this.r = this.r < -this.mPI ? -this.mPI : this.r;
    let i2 = 1 / this.cirRange, e2 = (this.r + this.mPI) * i2, h2 = this.range * e2 + this.min - this.old;
    (h2 >= this.step || h2 <= this.step) && (h2 = Math.floor(h2 / this.step), this.value = this.numValue(this.old + h2 * this.step), this.update(true), this.old = this.value, this.oldr = this.r);
  }
  wheel(t2) {
    if ("knob" === this.testZone(t2)) {
      let s2 = this.value - this.step * t2.delta;
      return s2 > this.max ? s2 = this.isCyclic ? this.min : this.max : s2 < this.min && (s2 = this.isCyclic ? this.max : this.min), this.setValue(s2), this.old = s2, this.update(true), true;
    }
    return false;
  }
  makeGrad() {
    let t2, s2, i2, e2, h2, o2, n2, r2 = "", l2 = 64, a2 = Math.PI + this.mPI, c2 = Math.PI - this.mPI;
    this.step > 5 ? (s2 = this.range / this.step, t2 = (a2 - c2) / s2) : (t2 = (a2 - c2) / l2 * 2, s2 = 32);
    for (let c3 = 0; c3 <= s2; ++c3)
      i2 = a2 - t2 * c3, e2 = l2 + 44 * Math.sin(i2), h2 = l2 + 44 * Math.cos(i2), o2 = l2 + 40 * Math.sin(i2), n2 = l2 + 40 * Math.cos(i2), r2 += "M" + e2 + " " + h2 + " L" + o2 + " " + n2 + " ";
    return r2;
  }
  update(t2) {
    this.c[2].textContent = this.value, this.percent = (this.value - this.min) / this.range;
    let s2 = Math.PI + this.mPI, i2 = this.percent * this.cirRange - this.mPI, e2 = Math.sin(i2), o2 = Math.cos(i2), n2 = 25 * e2 + 64, r2 = -25 * o2 + 64, l2 = 20 * e2 + 64, a2 = -20 * o2 + 64;
    if (this.setSvg(this.c[3], "d", "M " + n2 + " " + r2 + " L " + l2 + " " + a2, 1), this.model > 0) {
      let t3 = 36 * Math.sin(s2) + 64, n3 = 36 * Math.cos(s2) + 64, r3 = 36 * e2 + 64, l3 = -36 * o2 + 64, a3 = i2 <= Math.PI - this.mPI ? 0 : 1;
      this.setSvg(this.c[3], "d", "M " + t3 + "," + n3 + " A 36,36 1 " + a3 + " 1 " + r3 + "," + l3, 4);
      let c2 = h.pack(h.lerpColor(h.unpack(h.ColorLuma(this.colors.text, -0.75)), h.unpack(this.colors.text), this.percent));
      this.setSvg(this.c[3], "stroke", c2, 4);
    }
    t2 && this.send();
  }
};
var b = class extends r {
  constructor(t2 = {}) {
    super(t2), this.hideCurrent = false, this.path = t2.path || "", this.format = t2.format || "", this.isWithImage = "" !== this.path, this.preLoadComplete = false, this.tmpImage = {}, this.tmpUrl = [], this.m = void 0 !== t2.m ? t2.m : 5;
    let s2 = t2.align || "left", i2 = t2.scrollSize || 10;
    this.ss = i2 + 1, this.sMode = 0, this.tMode = 0, this.listOnly = t2.listOnly || false, this.staticTop = t2.staticTop || false, this.isSelectable = this.listOnly, void 0 !== t2.select && (t2.selectable = t2.select), void 0 !== t2.selectable && (this.isSelectable = t2.selectable), "" === this.txt && (this.p = 0);
    let e2 = Math.floor(0.5 * this.h) - 3, h2 = this.colors;
    if (this.c[2] = this.dom("div", this.css.basic + "top:0; display:none; border-radius:" + this.radius + "px;"), this.c[3] = this.dom("div", this.css.item + "padding:0px " + this.m + "px; margin-bottom:0px; position:absolute; justify-content:" + s2 + "; text-align:" + s2 + "; line-height:" + (this.h - 4) + "px; top:1px; background:" + h2.button + "; height:" + (this.h - 2) + "px; border:1px solid " + h2.border + "; border-radius:" + this.radius + "px;"), this.c[4] = this.dom("path", this.css.basic + "position:absolute; width:6px; height:6px; top:" + e2 + "px;", { d: this.svgs.g1, fill: h2.text, stroke: "none" }), this.scrollerBack = this.dom("div", this.css.basic + "right:0px; width:" + i2 + "px; background:" + h2.back + "; display:none;"), this.scroller = this.dom("div", this.css.basic + "right:" + 0.5 * (i2 - 0.25 * i2) + "px; width:" + 0.25 * i2 + "px; background:" + h2.text + "; display:none; "), this.c[3].style.color = h2.text, this.list = [], this.refObject = null, t2.list) {
      if (t2.list instanceof Array)
        this.list = t2.list;
      else if (t2.list instanceof Object) {
        this.refObject = t2.list;
        for (let t3 in this.refObject)
          this.list.push(t3);
      }
    }
    this.items = [], this.prevName = "", this.tmpId = 0, this.baseH = this.h, this.itemHeight = t2.itemHeight || this.h, this.full = t2.full || false, this.py = 0, this.ww = this.sb, this.scroll = false, this.isDown = false, this.current = null, this.side = t2.side || "down", this.up = "down" === this.side ? 0 : 1, this.up ? (this.c[2].style.top = "auto", this.c[3].style.top = "auto", this.c[4].style.top = "auto", this.c[2].style.bottom = this.h - 2 + "px", this.c[3].style.bottom = "1px", this.c[4].style.bottom = e2 + "px") : this.c[2].style.top = this.baseH + "px", this.listIn = this.dom("div", this.css.basic + "left:0; top:0; width:100%; background:none;"), this.listIn.name = "list", this.topList = 0, this.c[2].appendChild(this.listIn), this.c[2].appendChild(this.scrollerBack), this.c[2].appendChild(this.scroller), void 0 !== t2.value ? isNaN(t2.value) ? this.value = t2.value : this.value = this.list[t2.value] : this.value = this.list[0], this.isOpenOnStart = t2.open || false, this.listOnly && (this.baseH = 5, this.c[3].style.display = "none", this.c[4].style.display = "none", this.c[2].style.top = this.baseH + "px", this.isOpenOnStart = true), this.miniCanvas = t2.miniCanvas || false, this.canvasBg = t2.canvasBg || "rgba(0,0,0,0)", this.imageSize = t2.imageSize || [20, 20], this.drag = t2.drag || false, this.dragout = t2.dragout || false, this.dragstart = t2.dragstart || null, this.dragend = t2.dragend || null, this.setList(this.list), this.init(), this.isWithImage && this.preloadImage(), this.isOpenOnStart && this.open(true), this.baseH += this.mtop;
  }
  preloadImage() {
    this.preLoadComplete = false, this.tmpImage = {};
    for (let t2 = 0; t2 < this.list.length; t2++)
      this.tmpUrl.push(this.list[t2]);
    this.loadOne();
  }
  nextImg() {
    null !== this.c && (this.tmpUrl.shift(), 0 === this.tmpUrl.length ? (this.preLoadComplete = true, this.addImages()) : this.loadOne());
  }
  loadOne() {
    let t2 = this, s2 = this.tmpUrl[0], i2 = document.createElement("img");
    i2.style.cssText = "position:absolute; width:" + t2.imageSize[0] + "px; height:" + t2.imageSize[1] + "px", i2.setAttribute("src", this.path + s2 + this.format), i2.addEventListener("load", function() {
      t2.imageSize[2] = i2.width, t2.imageSize[3] = i2.height, t2.tmpImage[s2] = i2, t2.nextImg();
    });
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return "";
    if (this.up && this.isOpen) {
      if (s2.y > this.h - this.baseH)
        return "title";
      if (this.scroll && s2.x > this.sa + this.sb - this.ss)
        return "scroll";
      if (s2.x > this.sa)
        return this.testItems(s2.y - this.baseH);
    } else {
      if (s2.y < this.baseH + 2)
        return "title";
      if (this.isOpen) {
        if (this.scroll && s2.x > this.sa + this.sb - this.ss)
          return "scroll";
        if (s2.x > this.sa)
          return this.testItems(s2.y - this.baseH);
      }
    }
    return "";
  }
  testItems(t2) {
    let s2, i2, e2, h2 = "", o2 = this.items, n2 = o2.length;
    for (; n2--; )
      if (s2 = o2[n2], i2 = s2.posy + this.topList, e2 = s2.posy + this.itemHeight + 1 + this.topList, t2 >= i2 && t2 <= e2)
        return h2 = "item" + n2, this.modeItem(0), this.current = s2, this.modeItem(1), h2;
    return h2;
  }
  modeItem(t2) {
    if (!this.current)
      return;
    this.current.select && 0 === t2 && (t2 = 2);
    let s2 = this.colors;
    switch (t2) {
      case 0:
        this.current.style.background = s2.back, this.current.style.color = s2.text;
        break;
      case 1:
        this.current.style.background = s2.over, this.current.style.color = s2.textOver;
        break;
      case 2:
        this.current.style.background = s2.select, this.current.style.color = s2.textSelect;
    }
  }
  unSelected() {
    this.current && (this.modeItem(0), this.current = null);
  }
  selected() {
    this.current && (this.resetItems(), this.modeItem(2), this.current.select = true);
  }
  resetItems() {
    let t2 = this.items.length;
    for (; t2--; )
      this.items[t2].select = false, this.items[t2].style.background = this.colors.back, this.items[t2].style.color = this.colors.text;
  }
  hideActive() {
    this.hideCurrent && (this.current && (this.tmpId = this.current.id), this.resetHide());
  }
  resetHide() {
    console.log(this.tmpId);
    let t2 = this.items.length;
    for (; t2--; )
      t2 === this.tmpId ? (this.items[t2].style.height = "0px", this.items[t2].posy = -1) : (this.items[t2].style.height = this.itemHeight + "px", this.items[t2].posy = (this.itemHeight + 1) * (t2 - 1));
  }
  mouseup(t2) {
    this.isDown = false;
  }
  mousedown(t2) {
    let s2 = this.testZone(t2);
    return !!s2 && ("scroll" === s2 ? (this.isDown = true, this.mousemove(t2)) : "title" === s2 ? (this.modeTitle(2), this.listOnly || (this.hideActive(), this.isOpen ? this.close() : this.open())) : this.current && (this.value = this.list[this.current.id], this.isSelectable && this.selected(), this.send(this.value), this.listOnly || (this.close(), this.setTopItem())), true);
  }
  mousemove(t2) {
    let s2 = false, i2 = this.testZone(t2);
    if (!i2)
      return s2;
    if ("title" === i2)
      this.unSelected(), this.modeTitle(1), this.cursor("pointer");
    else if ("scroll" === i2) {
      if (this.cursor("s-resize"), this.modeScroll(1), this.isDown) {
        this.modeScroll(2);
        let s3 = this.zone.y + this.baseH - 2;
        this.update(t2.clientY - s3 - 0.5 * this.sh);
      }
    } else
      this.modeTitle(0), this.modeScroll(0), this.cursor("pointer");
    return i2 !== this.prevName && (s2 = true), this.prevName = i2, s2;
  }
  wheel(t2) {
    return "title" !== this.testZone(t2) && (this.py += 10 * t2.delta, this.update(this.py), true);
  }
  reset() {
    this.prevName = "", this.unSelected(), this.modeTitle(0), this.modeScroll(0);
  }
  modeScroll(t2) {
    if (t2 === this.sMode)
      return;
    let s2 = this.scroller.style, i2 = this.colors;
    switch (t2) {
      case 0:
        s2.background = i2.text;
        break;
      case 1:
      case 2:
        s2.background = i2.select;
    }
    this.sMode = t2;
  }
  modeTitle(t2) {
    if (t2 === this.tMode)
      return;
    let s2 = this.s, i2 = this.colors;
    switch (t2) {
      case 0:
        s2[3].color = i2.text, s2[3].background = i2.button;
        break;
      case 1:
        s2[3].color = i2.textOver, s2[3].background = i2.overoff;
        break;
      case 2:
        s2[3].color = i2.textSelect, s2[3].background = i2.overoff;
    }
    this.tMode = t2;
  }
  clearList() {
    for (; this.listIn.children.length; )
      this.listIn.removeChild(this.listIn.lastChild);
    this.items = [];
  }
  setList(t2) {
    this.clearList(), this.list = t2, this.length = this.list.length;
    let s2, e2, h2 = this.hideCurrent ? this.length - 1 : this.length;
    this.maxItem = this.full ? h2 : 5, this.maxItem = h2 < this.maxItem ? h2 : this.maxItem, this.maxHeight = this.maxItem * (this.itemHeight + 1) + 2, this.max = h2 * (this.itemHeight + 1) + 2, this.ratio = this.maxHeight / this.max, this.sh = this.maxHeight * this.ratio, this.range = this.maxHeight - this.sh, this.c[2].style.height = this.maxHeight + "px", this.scrollerBack.style.height = this.maxHeight + "px", this.scroller.style.height = this.sh + "px", this.max > this.maxHeight && (this.ww = this.sb - this.ss, this.scroll = true), this.miniCanvas && (this.tmpCanvas = document.createElement("canvas"), this.tmpCanvas.width = this.imageSize[0], this.tmpCanvas.height = this.imageSize[1], this.tmpCtx = this.tmpCanvas.getContext("2d"), this.tmpCtx.fillStyle = this.canvasBg, this.tmpCtx.fillRect(0, 0, this.imageSize[0], this.imageSize[1]));
    for (let t3 = 0; t3 < this.length; t3++) {
      if (e2 = this.list[t3], s2 = this.dom("div", this.css.item + "padding:0px " + (this.m + 1) + "px; width:" + this.ww + "px; height:" + this.itemHeight + "px; line-height:" + (this.itemHeight - 2) + "px; color:" + this.colors.text + "; background:" + this.colors.back + ";"), s2.name = "item" + t3, s2.id = t3, s2.select = false, s2.posy = (this.itemHeight + 1) * t3, this.listIn.appendChild(s2), this.items.push(s2), e2 === this.value && (this.current = s2), this.isWithImage || (s2.textContent = e2), this.miniCanvas) {
        let t4 = new Image();
        t4.src = this.tmpCanvas.toDataURL(), t4.style.cssText = "margin-right:4px;", s2.appendChild(t4), this.tmpImage[e2] = t4;
      }
      this.dragout && (s2.img = this.tmpImage[e2], s2.style.pointerEvents = "auto", s2.draggable = "true", s2.addEventListener("dragstart", this.dragstart || function() {
      }), s2.addEventListener("drag", this.drag || function() {
      }), s2.addEventListener("dragleave", function() {
        i.fakeUp();
      }), s2.addEventListener("dragend", this.dragend || (function() {
      }).bind(this)));
    }
    this.setTopItem(), this.isSelectable && this.selected();
  }
  drawImage(t2, s2, i2, e2, h2, o2) {
    this.tmpCtx.clearRect(0, 0, this.imageSize[0], this.imageSize[1]), this.tmpCtx.drawImage(s2, i2, e2, h2, o2, 0, 0, this.imageSize[0], this.imageSize[1]), this.tmpImage[t2].src = this.tmpCanvas.toDataURL();
  }
  addImages() {
    let t2 = this.list.length;
    for (let s2 = 0; s2 < t2; s2++)
      this.items[s2].appendChild(this.tmpImage[this.list[s2]]);
    this.setTopItem();
  }
  setValue(t2) {
    isNaN(t2) ? this.value = t2 : this.value = this.list[t2], this.setTopItem();
  }
  setTopItem() {
    if (!this.staticTop) {
      if (this.isWithImage) {
        if (!this.preLoadComplete)
          return;
        this.c[3].children.length || (this.canvas = document.createElement("canvas"), this.canvas.width = this.imageSize[0], this.canvas.height = this.imageSize[1], this.canvas.style.cssText = "margin-right:4px;", this.ctx = this.canvas.getContext("2d"), this.c[3].style.textAlign = "left", this.c[3].style.justifyContent = "left", this.c[3].appendChild(this.canvas)), this.tmpImage[this.value], this.ctx.drawImage(this.tmpImage[this.value], 0, 0, this.imageSize[2], this.imageSize[3], 0, 0, this.imageSize[0], this.imageSize[1]);
      } else
        this.c[3].textContent = this.value;
      this.miniCanvas && (this.c[3].children.length || (this.canvas = document.createElement("canvas"), this.canvas.width = this.imageSize[0], this.canvas.height = this.imageSize[1], this.canvas.style.cssText = "margin-right:4px;", this.ctx = this.canvas.getContext("2d"), this.c[3].style.textAlign = "left", this.c[3].style.justifyContent = "left", this.c[3].appendChild(this.canvas)), this.ctx.drawImage(this.tmpImage[this.value], 0, 0));
    }
  }
  update(t2) {
    this.scroll && (t2 = (t2 = t2 < 0 ? 0 : t2) > this.range ? this.range : t2, this.topList = -Math.floor(t2 / this.ratio), this.listIn.style.top = this.topList + "px", this.scroller.style.top = Math.floor(t2) + "px", this.py = t2);
  }
  parentHeight(t2) {
    null !== this.group ? this.group.calc(t2) : this.isUI && this.main.calc(t2);
  }
  open(t2) {
    super.open(), this.update(0), this.h = this.maxHeight + this.baseH + 5, this.scroll ? (this.scroller.style.display = "block", this.scrollerBack.style.display = "block") : (this.topList = 0, this.h = this.baseH + 5 + this.max, this.scroller.style.display = "none", this.scrollerBack.style.display = "none"), this.s[0].height = this.h + "px", this.s[2].display = "block", this.up ? (this.zone.y -= this.h - (this.baseH - 10), this.setSvg(this.c[4], "d", this.svgs.g1)) : this.setSvg(this.c[4], "d", this.svgs.g2), this.rSizeContent();
    let s2 = this.h - this.baseH;
    this.zone.h = this.h, t2 || this.parentHeight(s2);
  }
  close() {
    super.close(), this.up && (this.zone.y += this.h - (this.baseH - 10));
    let t2 = this.h - this.baseH;
    this.h = this.baseH, this.s[0].height = this.h + "px", this.s[2].display = "none", this.setSvg(this.c[4], "d", this.svgs.g1), this.zone.h = this.h, this.parentHeight(-t2);
  }
  text(t2) {
    this.c[3].textContent = t2;
  }
  rSizeContent() {
    let t2 = this.length;
    for (; t2--; )
      this.listIn.children[t2].style.width = this.ww + "px";
  }
  rSize() {
    super.rSize();
    let t2 = this.s, s2 = this.sb, i2 = this.sa;
    void 0 !== t2[2] && (t2[2].width = s2 + "px", t2[2].left = i2 + "px", t2[3].width = s2 + "px", t2[3].left = i2 + "px", t2[4].left = i2 + s2 - 15 + "px", this.ww = s2, this.max > this.maxHeight && (this.ww = s2 - this.ss), this.isOpen && this.rSizeContent());
  }
};
var f = class extends r {
  constructor(t2 = {}) {
    super(t2), this.setTypeNumber(t2), this.allway = t2.allway || false, this.isDown = false, this.value = [0], this.multy = 1, this.invmulty = 1, this.isSingle = true, this.isAngle = false, this.isVector = false, t2.isAngle && (this.isAngle = true, this.multy = h.torad, this.invmulty = h.todeg), this.isDrag = t2.drag || false, void 0 !== t2.value && (isNaN(t2.value) ? t2.value instanceof Array ? (this.value = t2.value, this.isSingle = false) : t2.value instanceof Object && (this.value = [], void 0 !== t2.value.x && (this.value[0] = t2.value.x), void 0 !== t2.value.y && (this.value[1] = t2.value.y), void 0 !== t2.value.z && (this.value[2] = t2.value.z), void 0 !== t2.value.w && (this.value[3] = t2.value.w), this.isSingle = false, this.isVector = true) : this.value = [t2.value]), this.lng = this.value.length, this.tmp = [], this.current = -1, this.prev = { x: 0, y: 0, d: 0, v: 0 };
    let s2 = this.colors;
    this.c[2] = this.dom("div", this.css.basic + " background:" + s2.select + "; top:4px; width:0px; height:" + (this.h - 8) + "px;"), this.cMode = [];
    let i2 = this.lng;
    for (; i2--; )
      this.isAngle && (this.value[i2] = (180 * this.value[i2] / Math.PI).toFixed(this.precision)), this.c[3 + i2] = this.dom("div", this.css.txtselect + "top:1px; height:" + (this.h - 2) + "px; color:" + s2.text + "; background:" + s2.back + "; borderColor:" + s2.border + "; border-radius:" + this.radius + "px;"), t2.center && (this.c[2 + i2].style.textAlign = "center"), this.c[3 + i2].textContent = this.value[i2], this.c[3 + i2].style.color = this.colors.text, this.c[3 + i2].isNum = true, this.cMode[i2] = 0;
    this.selectId = 3 + this.lng, this.c[this.selectId] = this.dom("div", this.css.txtselect + "position:absolute; top:2px; height:" + (this.h - 4) + "px; padding:0px 0px; width:0px; color:" + s2.textSelect + "; background:" + s2.select + "; border:none; border-radius:0px;"), this.cursorId = 4 + this.lng, this.c[this.cursorId] = this.dom("div", this.css.basic + "top:2px; height:" + (this.h - 4) + "px; width:0px; background:" + s2.text + ";"), this.init();
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return "";
    let i2 = this.lng, e2 = this.tmp;
    for (; i2--; )
      if (s2.x > e2[i2][0] && s2.x < e2[i2][2])
        return i2;
    return "";
  }
  mousedown(t2) {
    let s2 = this.testZone(t2);
    return !this.isDown && (this.isDown = true, "" !== s2 && (this.current = s2, this.prev = { x: t2.clientX, y: t2.clientY, d: 0, v: this.isSingle ? parseFloat(this.value) : parseFloat(this.value[this.current]) }, this.setInput(this.c[3 + this.current])), this.mousemove(t2));
  }
  mouseup(t2) {
    return !!this.isDown && (this.isDown = false, this.prev = { x: 0, y: 0, d: 0, v: 0 }, this.mousemove(t2));
  }
  mousemove(t2) {
    let s2 = false, i2 = 0;
    if ("" === this.testZone(t2) ? this.cursor() : this.isDrag ? this.cursor(-1 !== this.current ? "move" : "pointer") : this.cursor("text"), !this.isDrag)
      return this.isDown && (i2 = t2.clientX - this.zone.x - 3), -1 !== this.current && (i2 -= this.tmp[this.current][0]), this.upInput(i2, this.isDown);
    if (-1 !== this.current) {
      this.prev.d += t2.clientX - this.prev.x - (t2.clientY - this.prev.y);
      let i3 = this.prev.v + this.prev.d * this.step;
      this.value[this.current] = this.numValue(i3), this.c[3 + this.current].textContent = this.value[this.current], this.validate(), this.prev.x = t2.clientX, this.prev.y = t2.clientY, s2 = true;
    }
    return s2;
  }
  reset() {
    return false;
  }
  setValue(t2) {
    this.isVector ? (void 0 !== t2.x && (this.value[0] = t2.x), void 0 !== t2.y && (this.value[1] = t2.y), void 0 !== t2.z && (this.value[2] = t2.z), void 0 !== t2.w && (this.value[3] = t2.w)) : this.value = this.isSingle ? [t2] : t2, this.update();
  }
  sameStr(t2) {
    let s2 = this.value.length;
    for (; s2--; )
      this.c[3 + s2].textContent = t2;
  }
  update(t2) {
    let s2 = this.value.length;
    for (; s2--; )
      this.value[s2] = this.numValue(this.value[s2] * this.invmulty), this.c[3 + s2].textContent = this.value[s2];
    t2 && this.send();
  }
  send(t2) {
    t2 = t2 || this.value, this.isSend = true, null !== this.objectLink && (this.isVector ? this.objectLink[this.objectKey].fromArray(t2) : this.objectLink[this.objectKey] = t2), this.callback && this.callback(t2, this.objectKey), this.isSend = false;
  }
  select(t2, s2, i2, e2) {
    let h2 = this.s, o2 = -1 !== this.current ? this.tmp[this.current][0] + 5 : 0;
    h2[this.cursorId].width = "1px", h2[this.cursorId].left = o2 + t2 + "px", h2[this.selectId].left = o2 + s2 + "px", h2[this.selectId].width = i2 + "px", this.c[this.selectId].innerHTML = e2;
  }
  unselect() {
    let t2 = this.s;
    t2 && (this.c[this.selectId].innerHTML = "", t2[this.selectId].width = "0px", t2[this.cursorId].width = "0px");
  }
  validate(t2) {
    let s2 = [], i2 = this.lng;
    for (this.allway && (t2 = true); i2--; ) {
      if (isNaN(this.c[3 + i2].textContent))
        this.c[3 + i2].textContent = this.value[i2];
      else {
        let t3 = this.numValue(this.c[3 + i2].textContent);
        this.c[3 + i2].textContent = t3, this.value[i2] = t3;
      }
      s2[i2] = this.value[i2] * this.multy;
    }
    t2 && this.send(this.isSingle ? s2[0] : s2);
  }
  rSize() {
    super.rSize();
    let t2 = this.colors.sx, s2 = t2 * (this.lng - 1), i2 = (this.sb - s2) / this.lng, e2 = this.s, h2 = this.lng;
    for (; h2--; )
      this.tmp[h2] = [this.sa + i2 * h2 + t2 * h2, i2], this.tmp[h2][2] = this.tmp[h2][0] + this.tmp[h2][1], e2[3 + h2].left = this.tmp[h2][0] + "px", e2[3 + h2].width = this.tmp[h2][1] + "px";
  }
};
var w = class extends r {
  constructor(t2 = {}) {
    super(t2), this.setTypeNumber(t2), this.model = t2.stype || 0, void 0 !== t2.mode && (this.model = t2.mode), this.isDown = false, this.isOver = false, this.allway = t2.allway || false, this.isDeg = t2.isDeg || false, this.isCyclic = t2.cyclic || false, this.firstImput = false;
    let s2 = this.colors;
    if (this.c[2] = this.dom("div", this.css.txtselect + "border:none; background:none; width:47px; color:" + s2.text + ";"), this.c[3] = this.dom("div", this.css.basic + " top:0; height:" + this.h + "px;"), this.c[4] = this.dom("div", this.css.basic + "background:" + s2.back + "; top:2px; height:" + (this.h - 4) + "px;"), this.c[5] = this.dom("div", this.css.basic + "left:4px; top:5px; height:" + (this.h - 10) + "px; background:" + s2.text + ";"), this.c[2].isNum = true, this.c[2].style.height = this.h - 2 + "px", this.c[2].style.lineHeight = this.h - 10 + "px", 0 !== this.model) {
      let t3 = 4, i2 = 4, e2 = 8, h2 = this.h - 6, o2 = 16;
      2 === this.model && (t3 = 0, i2 = 2, e2 = 4, o2 = 2, h2 = 0.5 * (this.h - 6)), 3 === this.model && (this.c[5].style.visible = "none"), this.c[4].style.borderRadius = t3 + "px", this.c[4].style.height = e2 + "px", this.c[4].style.top = 0.5 * this.h - i2 + "px", this.c[5].style.borderRadius = 0.5 * t3 + "px", this.c[5].style.height = i2 + "px", this.c[5].style.top = 0.5 * this.h - 0.5 * i2 + "px", this.c[6] = this.dom("div", this.css.basic + "border-radius:" + o2 + "px; margin-left:" + 0.5 * -h2 + "px; background:" + s2.text + "; left:4px; top:3px; height:" + (this.h - 6) + "px; width:" + h2 + "px;");
    }
    this.init();
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.x >= this.txl ? "text" : s2.x >= this.sa ? "scroll" : "";
  }
  mouseup(t2) {
    this.isDown && (this.isDown = false);
  }
  mousedown(t2) {
    let s2 = this.testZone(t2);
    return !!s2 && ("scroll" === s2 && (this.isDown = true, this.old = this.value, this.mousemove(t2)), true);
  }
  mousemove(t2) {
    let s2 = false;
    if ("scroll" === this.testZone(t2) ? (this.mode(1), this.cursor("w-resize")) : this.cursor(), this.isDown) {
      let i2 = (t2.clientX - (this.zone.x + this.sa) - 3) / this.ww * this.range + this.min - this.old;
      (i2 >= this.step || i2 <= this.step) && (i2 = Math.floor(i2 / this.step), this.value = this.numValue(this.old + i2 * this.step), this.update(true), this.old = this.value), s2 = true;
    }
    return s2;
  }
  wheel(t2) {
    if ("scroll" === this.testZone(t2)) {
      let s2 = this.value - this.step * t2.delta;
      return s2 > this.max ? s2 = this.isCyclic ? this.min : this.max : s2 < this.min && (s2 = this.isCyclic ? this.max : this.min), this.setValue(s2), this.old = s2, this.update(true), true;
    }
    return false;
  }
  validate() {
    let t2 = this.c[2].textContent;
    isNaN(t2) ? this.c[2].textContent = this.value + (this.isDeg ? "°" : "") : (this.value = this.numValue(t2), this.update(true));
  }
  reset() {
    this.isDown = false, this.mode(0);
  }
  mode(t2) {
    let s2 = this.s, i2 = this.colors;
    switch (t2) {
      case 0:
        s2[2].color = i2.text, s2[4].background = i2.back, s2[5].background = i2.text, 0 !== this.model && (s2[6].background = i2.text);
        break;
      case 1:
        s2[2].color = i2.textOver, s2[4].background = i2.back, s2[5].background = i2.textOver, 0 !== this.model && (s2[6].background = i2.textOver);
    }
  }
  update(t2) {
    let s2 = Math.floor(this.ww * ((this.value - this.min) / this.range));
    3 !== this.model && (this.s[5].width = s2 + "px"), this.s[6] && (this.s[6].left = this.sa + s2 + 3 + "px"), this.c[2].textContent = this.value + (this.isDeg ? "°" : ""), t2 && this.send();
  }
  rSize() {
    super.rSize();
    let t2 = this.sb - this.sc;
    this.ww = t2 - 6;
    let s2 = this.sc;
    !this.isUI && this.simple || (s2 = this.sc + 10), this.txl = this.w - s2 + 2;
    let i2 = this.s;
    i2[2].width = this.sc - 6 + "px", i2[2].left = this.txl + 4 + "px", i2[3].left = this.sa + "px", i2[3].width = t2 + "px", i2[4].left = this.sa + "px", i2[4].width = t2 + "px", i2[5].left = this.sa + 3 + "px", this.update();
  }
};
var y = class extends r {
  constructor(t2 = {}) {
    super(t2), this.cmode = 0, this.value = void 0 !== t2.value ? t2.value : "", this.placeHolder = t2.placeHolder || "", this.allway = t2.allway || false, this.editable = void 0 === t2.edit || t2.edit, this.isDown = false;
    let s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txtselect + "top:1px; height:" + (this.h - 2) + "px; color:" + s2.text + "; background:" + s2.back + "; borderColor:" + s2.border + "; border-radius:" + this.radius + "px;"), this.c[2].textContent = this.value, this.c[3] = this.dom("div", this.css.txtselect + "position:absolute; top:2px; height:" + (this.h - 4) + "px; padding:0px 0px; width:0px; color:" + s2.textSelect + "; background:" + s2.select + "; border:none; border-radius:0px;"), this.c[4] = this.dom("div", this.css.basic + "top:2px; height:" + (this.h - 4) + "px; width:0px; background:" + s2.text + ";"), this.c[5] = this.dom("div", this.css.txtselect + "top:1px; height:" + (this.h - 2) + "px; border:none; justify-content: center; font-style: italic; color:" + s2.border + ";"), "" === this.value && (this.c[5].textContent = this.placeHolder), this.init();
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.x >= this.sa ? "text" : "";
  }
  mouseup(t2) {
    if (this.editable)
      return !!this.isDown && (this.isDown = false, this.mousemove(t2));
  }
  mousedown(t2) {
    if (!this.editable)
      return;
    let s2 = this.testZone(t2);
    return !this.isDown && (this.isDown = true, "text" === s2 && this.setInput(this.c[2]), this.mousemove(t2));
  }
  mousemove(t2) {
    if (!this.editable)
      return;
    let s2 = 0;
    return "text" === this.testZone(t2) ? this.cursor("text") : this.cursor(), this.isDown && (s2 = t2.clientX - this.zone.x), this.upInput(s2 - this.sa - 3, this.isDown);
  }
  update() {
    this.c[2].textContent = this.value;
  }
  reset() {
    this.cursor();
  }
  select(t2, s2, i2, e2) {
    let h2 = this.s, o2 = this.sa + 5;
    h2[4].width = "1px", h2[4].left = o2 + s2 + "px", h2[3].left = o2 + s2 + "px", h2[3].width = i2 + "px", this.c[3].innerHTML = e2;
  }
  unselect() {
    let t2 = this.s;
    t2 && (t2[3].width = "0px", this.c[3].innerHTML = "t", t2[4].width = "0px");
  }
  validate(t2) {
    this.allway && (t2 = true), this.value = this.c[2].textContent, "" !== this.value ? this.c[5].textContent = "" : this.c[5].textContent = this.placeHolder, t2 && this.send();
  }
  rSize() {
    super.rSize();
    let t2 = this.s;
    t2[2].left = this.sa + "px", t2[2].width = this.sb + "px", t2[5].left = this.sa + "px", t2[5].width = this.sb + "px";
  }
};
var k = class extends r {
  constructor(t2 = {}) {
    super(t2);
    let s2 = t2.prefix || "";
    this.c[2] = this.dom("div", this.css.txt + "justify-content:right; width:60px; line-height:" + (this.h - 8) + "px; color:" + this.colors.text), 31 === this.h && (this.s[0].height = this.h + "px", this.s[1].top = "8px", this.c[2].style.top = "8px");
    let i2 = this.s;
    i2[1].justifyContent = t2.align || "left", i2[1].fontWeight = t2.fontWeight || "bold", this.c[1].textContent = this.txt.substring(0, 1).toUpperCase() + this.txt.substring(1).replace("-", " "), this.c[2].textContent = s2, this.init();
  }
  text(t2) {
    this.c[1].textContent = t2;
  }
  text2(t2) {
    this.c[2].textContent = t2;
  }
  rSize() {
    super.rSize(), this.s[1].width = this.w + "px", this.s[2].left = this.w + "px";
  }
  setColor(t2) {
    this.s[1].color = t2, this.s[2].color = t2;
  }
};
var S = class extends r {
  constructor(t2 = {}) {
    super(t2), this.value = t2.value || "", this.isDown = false, this.onActif = t2.onActif || function() {
    };
    const s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txt + this.css.button + " top:1px; background:" + s2.button + "; height:" + (this.h - 2) + "px; border:" + s2.buttonBorder + "; border-radius:15px; width:30px; left:10px;"), this.c[3] = this.dom("div", this.css.txtselect + "height:" + (this.h - 4) + "px; background:" + s2.inputBg + "; borderColor:" + s2.inputBorder + "; border-radius:" + this.radius + "px;"), this.c[3].textContent = this.value;
    let i2 = Math.floor(0.5 * this.h) - 7;
    this.c[4] = this.dom("path", this.css.basic + "position:absolute; width:14px; height:14px; left:5px; top:" + i2 + "px;", { d: this.svgs.cursor, fill: s2.text, stroke: "none" }), this.stat = 1, this.isActif = false, this.init();
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.x > this.sa && s2.x < this.sa + 30 ? "over" : "0";
  }
  mouseup(t2) {
    return !!this.isDown && (this.isDown = false, this.mousemove(t2));
  }
  mousedown(t2) {
    return !!this.testZone(t2) && (this.isDown = true, this.mousemove(t2));
  }
  mousemove(t2) {
    let s2 = false;
    return "over" === this.testZone(t2) ? (this.cursor("pointer"), s2 = this.mode(this.isDown ? 3 : 2)) : s2 = this.reset(), s2;
  }
  apply(t2) {
    (t2 = t2 || "") !== this.value && (this.value = t2, this.c[3].textContent = this.value, this.send()), this.mode(1);
  }
  update() {
    this.mode(3);
  }
  mode(t2) {
    let s2 = false, i2 = this.colors;
    if (this.stat !== t2) {
      switch (1 === t2 && (this.isActif = false), 3 === t2 && (this.isActif ? this.isActif = false : (this.isActif = true, t2 = 4, this.onActif(this))), 2 === t2 && this.isActif && (t2 = 4), this.stat = t2, t2) {
        case 1:
          this.s[2].color = i2.text, this.s[2].background = i2.button;
          break;
        case 2:
          this.s[2].color = i2.textOver, this.s[2].background = i2.overoff;
          break;
        case 3:
          this.s[2].color = i2.textOver, this.s[2].background = i2.action;
          break;
        case 4:
          this.s[2].color = i2.textSelect, this.s[2].background = i2.action;
      }
      s2 = true;
    }
    return s2;
  }
  reset() {
    return this.cursor(), this.mode(this.isActif ? 4 : 1);
  }
  text(t2) {
    this.c[3].textContent = t2;
  }
  rSize() {
    super.rSize();
    let t2 = this.s;
    t2[2].left = this.sa + "px", t2[3].left = this.sa + 40 + "px", t2[3].width = this.sb - 40 + "px", t2[4].left = this.sa + 8 + "px";
  }
};
var I = class extends r {
  constructor(t2 = {}) {
    super(t2), this.value = t2.value || "", this.refTexture = t2.texture || null, this.img = null, this.isDown = false, this.neverlock = true;
    const s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txt + this.css.button + " top:1px; background:" + s2.button + "; height:" + (this.h - 2) + "px; border:" + s2.buttonBorder + "; border-radius:15px; width:30px; left:10px;"), this.c[3] = this.dom("div", this.css.txtselect + "height:" + (this.h - 4) + "px; background:" + s2.inputBg + "; borderColor:" + s2.inputBorder + "; border-radius:" + this.radius + "px;"), this.c[3].textContent = this.value;
    let i2 = Math.floor(0.5 * this.h) - 7;
    this.c[4] = this.dom("path", this.css.basic + "position:absolute; width:14px; height:14px; left:5px; top:" + i2 + "px;", { d: this.svgs.load, fill: s2.text, stroke: "none" }), this.stat = 1, this.init();
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.x > this.sa && s2.x < this.sa + 30 ? "over" : "0";
  }
  mouseup(t2) {
    return !!this.isDown && (this.isDown = false, this.mousemove(t2));
  }
  mousedown(t2) {
    let s2 = this.testZone(t2);
    return !!s2 && ("over" === s2 && (this.isDown = true, o.load({ callback: this.changeBitmap.bind(this) })), this.mousemove(t2));
  }
  mousemove(t2) {
    let s2 = false;
    return "over" === this.testZone(t2) ? (this.cursor("pointer"), s2 = this.mode(this.isDown ? 3 : 2)) : s2 = this.reset(), s2;
  }
  changeBitmap(t2, s2) {
    t2 ? (this.img = t2, this.apply(s2)) : (this.img = null, this.apply("null"));
  }
  apply(t2) {
    (t2 = t2 || "") !== this.value && (this.value = t2, this.c[3].textContent = this.value, null !== this.img && (null !== this.objectLink && (this.objectLink[this.val] = t2), this.callback && this.callback(this.value, this.img, this.name))), this.mode(1);
  }
  update() {
    this.mode(3);
  }
  mode(t2) {
    let s2 = false, i2 = this.colors;
    if (this.stat !== t2) {
      switch (this.stat = t2, t2) {
        case 1:
          this.s[2].color = i2.text, this.s[2].background = i2.button;
          break;
        case 2:
          this.s[2].color = i2.textOver, this.s[2].background = i2.overoff;
          break;
        case 3:
          this.s[2].color = i2.textOver, this.s[2].background = i2.over;
          break;
        case 4:
          this.s[2].color = i2.textSelect, this.s[2].background = i2.select;
      }
      s2 = true;
    }
    return s2;
  }
  reset() {
    return this.cursor(), this.mode(this.isActif ? 4 : 1);
  }
  text(t2) {
    this.c[3].textContent = t2;
  }
  rSize() {
    super.rSize();
    let t2 = this.s;
    t2[2].left = this.sa + "px", t2[3].left = this.sa + 40 + "px", t2[3].width = this.sb - 40 + "px", t2[4].left = this.sa + 8 + "px";
  }
};
var C = class extends a {
  constructor(t2 = {}) {
    void 0 === t2.selectable && (t2.selectable = true), super(t2);
  }
};
var M = class extends r {
  constructor(t2 = {}) {
    super(t2), this.p = 100, this.value = this.txt, this.status = 1, this.itype = t2.itype || "none", this.val = this.itype, this.graph = this.svgs[this.itype];
    let s2 = Math.floor(0.5 * this.h) - 7;
    this.c[2] = this.dom("path", this.css.basic + "position:absolute; width:14px; height:14px; left:5px; top:" + s2 + "px;", { d: this.graph, fill: this.colors.text, stroke: "none" }), this.s[1].marginLeft = "20px", this.init();
  }
  mousemove(t2) {
    this.cursor("pointer");
  }
  mousedown(t2) {
    return this.isUI && this.main.resetItem(), this.selected(true), this.send(), true;
  }
  uiout() {
    this.isSelect ? this.mode(3) : this.mode(1);
  }
  uiover() {
    this.isSelect ? this.mode(4) : this.mode(2);
  }
  update() {
  }
  mode(t2) {
    let s2 = false;
    if (this.status !== t2) {
      this.status = t2;
      let i2 = this.s, e2 = this.colors;
      switch (t2) {
        case 1:
          this.status = 1, i2[1].color = e2.text, i2[0].background = "none";
          break;
        case 2:
          this.status = 2, i2[1].color = e2.textOver, i2[0].background = e2.back;
          break;
        case 3:
          this.status = 3, i2[1].color = e2.textSelect, i2[0].background = e2.select;
          break;
        case 4:
          this.status = 4, i2[1].color = e2.textOver, i2[0].background = e2.over;
      }
      s2 = true;
    }
    return s2;
  }
  reset() {
    this.cursor();
  }
  selected(t2) {
    this.isSelect && this.mode(1), this.isSelect = t2 || false, this.isSelect && this.mode(3);
  }
};
var L = class extends r {
  constructor(t2 = {}) {
    if (super(t2), this.values = [], t2.values) {
      if (t2.values instanceof Array)
        this.values = t2.values;
      else if (t2.values instanceof String)
        this.values = [t2.values];
      else if (t2.values instanceof Object) {
        this.refObject = t2.values;
        for (let t3 in this.refObject)
          this.values.push(t3);
      }
    }
    this.lng = this.values.length, this.value = t2.value || null;
    let s2 = this.colors;
    this.isSelectable = t2.selectable || false, this.spaces = t2.spaces || [s2.sx, s2.sy], this.bsize = t2.bsize || [90, this.h], this.bsizeMax = this.bsize[0], this.tmp = [], this.stat = [], this.grid = [2, Math.round(0.5 * this.lng)], this.h = this.grid[1] * this.bsize[1] + this.grid[1] * this.spaces[1], this.c[1].textContent = "", this.c[2] = this.dom("table", this.css.basic + "width:100%; border-spacing: " + (this.spaces[0] - 2) + "px " + this.spaces[1] + "px; border:none;");
    let i2, e2, h2, o2, n2 = 0;
    this.res = -1, this.isDown = false, this.neverlock = true, this.buttons = [], this.stat = [], this.tmpX = [], this.tmpY = [];
    for (let t3 = 0; t3 < this.grid[1]; t3++) {
      h2 = this.c[2].insertRow(), h2.style.cssText = "pointer-events:none;";
      for (let t4 = 0; t4 < this.grid[0]; t4++)
        e2 = h2.insertCell(), e2.style.cssText = "pointer-events:none;", this.values[n2] ? (o2 = false, this.values[n2] === this.value && this.isSelectable && (o2 = true), i2 = document.createElement("div"), i2.style.cssText = this.css.txt + this.css.button + "position:static; top:1px; width:" + this.bsize[0] + "px; height:" + (this.bsize[1] - 2) + "px; border:" + s2.borderSize + "px solid " + s2.border + "; left:auto; right:auto; border-radius:" + this.radius + "px;", i2.style.background = o2 ? s2.select : s2.button, i2.style.color = o2 ? s2.textSelect : s2.text, i2.innerHTML = this.values[n2], e2.appendChild(i2), this.buttons.push(i2), this.stat.push(1)) : (i2 = document.createElement("div"), i2.style.cssText = this.css.txt + "position:static; width:" + this.bsize[0] + "px; height:" + this.bsize[1] + "px; text-align:center; left:auto; right:auto; background:none;", e2.appendChild(i2)), i2.style.cssText += 0 === t4 ? "float:right;" : "float:left;", n2++;
    }
    this.s[0].border = "none", this.init();
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return -1;
    s2.y += this.mtop;
    let i2 = this.tmpX, e2 = this.tmpY, h2 = -1, o2 = -1, n2 = -1, r2 = this.grid[0];
    for (; r2--; )
      s2.x > i2[r2][0] && s2.x < i2[r2][1] && (o2 = r2);
    for (r2 = this.grid[1]; r2--; )
      s2.y > e2[r2][0] && s2.y < e2[r2][1] && (n2 = r2);
    return -1 !== o2 && -1 !== n2 && (h2 = o2 + 2 * n2, h2 > this.lng - 1 && (h2 = -1)), h2;
  }
  mouseup(t2) {
    return !!this.isDown && (this.isDown = false, -1 !== this.res && (this.value = this.values[this.res], this.send()), this.mousemove(t2));
  }
  mousedown(t2) {
    return !this.isDown && (this.isDown = true, this.mousemove(t2));
  }
  mousemove(t2) {
    let s2 = false;
    return this.res = this.testZone(t2), -1 !== this.res ? (this.cursor("pointer"), s2 = this.modes(this.isDown ? 3 : 2, this.res)) : s2 = this.reset(), s2;
  }
  modes(t2 = 1, s2 = -1) {
    let i2, e2, h2 = this.lng, o2 = false;
    for (; h2--; )
      e2 = t2, i2 = !!this.isSelectable && this.values[h2] === this.value, h2 === s2 ? i2 && 2 === e2 && (e2 = 3) : (e2 = 1, i2 && (e2 = 4)), this.mode(e2, h2) && (o2 = true);
    return o2;
  }
  mode(t2, s2) {
    let i2 = false, e2 = this.colors, h2 = this.buttons, o2 = s2;
    if (this.stat[s2] !== t2) {
      switch (this.stat[s2] = t2, t2) {
        case 1:
          h2[o2].style.color = e2.text, h2[o2].style.background = e2.button;
          break;
        case 2:
          h2[o2].style.color = e2.textOver, h2[o2].style.background = e2.overoff;
          break;
        case 3:
          h2[o2].style.color = e2.textOver, h2[o2].style.background = e2.over;
          break;
        case 4:
          h2[o2].style.color = e2.textSelect, h2[o2].style.background = e2.select;
      }
      i2 = true;
    }
    return i2;
  }
  reset() {
    return this.res = -1, this.cursor(), this.modes();
  }
  label(t2, s2) {
    this.buttons[s2].textContent = t2;
  }
  icon(t2, s2, i2) {
    this.buttons[i2].style.padding = (s2 || 0) + "px 0px", this.buttons[i2].innerHTML = t2;
  }
  testW() {
    let t2 = false;
    if (3 * this.spaces[0] + 2 * this.bsizeMax > this.w ? (this.bsize[0] = 0.5 * (this.w - 3 * this.spaces[0]), t2 = true) : this.bsize[0] !== this.bsizeMax && (this.bsize[0] = this.bsizeMax, t2 = true), !t2)
      return;
    let s2 = this.buttons.length;
    for (; s2--; )
      this.buttons[s2].style.width = this.bsize[0] + "px";
  }
  rSize() {
    let t2;
    super.rSize(), this.testW(), this.tmpX = [], this.tmpY = [];
    for (let s2 = 0; s2 < this.grid[0]; s2++)
      0 === s2 ? (t2 = 0.5 * this.w - 0.5 * this.spaces[0], this.tmpX.push([t2 - this.bsize[0], t2])) : (t2 = 0.5 * this.w + 0.5 * this.spaces[0], this.tmpX.push([t2, t2 + this.bsize[0]]));
    t2 = this.spaces[1];
    for (let s2 = 0; s2 < this.grid[1]; s2++)
      this.tmpY.push([t2, t2 + this.bsize[1]]), t2 += this.bsize[1] + this.spaces[1];
  }
};
var z = class extends r {
  constructor(t2 = {}) {
    super(t2), this.autoWidth = false, this.minw = this.w, this.diam = t2.diam || this.w, this.pos = new n(0, 0), this.maxPos = 90, this.model = t2.stype || 0, void 0 !== t2.mode && (this.model = t2.mode), this.min = void 0 === t2.min ? -1 : t2.min, this.max = void 0 === t2.max ? 1 : t2.max, this.range = 0.5 * (this.max - this.min), this.cmode = 0, this.c[0].style.display = "block", this.precision = void 0 === t2.precision ? 2 : t2.precision, this.value = Array.isArray(t2.value) && 2 == t2.value.length ? t2.value : [0, 0], this.h = t2.h || this.w + 10, this.c[0].style.width = this.w + "px", void 0 !== this.c[1] && (this.c[1].style.width = "100%", this.c[1].style.justifyContent = "center", this.top = 10, this.h += 10);
    let s2 = this.colors;
    this.c[2] = this.dom("div", this.css.txt + "justify-content:center; top:" + (this.h - 20) + "px; width:100%; color:" + s2.text), this.c[2].textContent = this.value;
    let i2 = this.getPad2d();
    this.setSvg(i2, "fill", s2.back, 0), this.setSvg(i2, "fill", s2.button, 1), this.setSvg(i2, "stroke", s2.back, 2), this.setSvg(i2, "stroke", s2.back, 3), this.setSvg(i2, "stroke", s2.text, 4), this.setSvg(i2, "viewBox", "0 0 " + this.diam + " " + this.diam), this.setCss(i2, { width: this.diam, height: this.diam, left: 0, top: this.top }), this.c[3] = i2, this.init(), this.setValue();
  }
  testZone(t2) {
    let s2 = this.local;
    return -1 === s2.x && -1 === s2.y ? "" : s2.y <= this.c[1].offsetHeight ? "title" : s2.y > this.h - this.c[2].offsetHeight ? "text" : "pad";
  }
  mouseup(t2) {
    return this.isDown = false, this.mode(0);
  }
  mousedown(t2) {
    if ("pad" === this.testZone(t2))
      return this.isDown = true, this.mousemove(t2), this.mode(1);
  }
  mousemove(t2) {
    if (!this.isDown)
      return;
    let s2 = 0.5 * this.w - (t2.clientX - this.zone.x), i2 = 0.5 * this.diam - (t2.clientY - this.zone.y - this.ytop), e2 = 256 / this.diam;
    s2 = -s2 * e2, i2 = -i2 * e2, s2 = h.clamp(s2, -this.maxPos, this.maxPos), i2 = h.clamp(i2, -this.maxPos, this.maxPos), this.setPos([s2, i2]), this.update(true);
  }
  mode(t2) {
    if (this.cmode === t2)
      return false;
    let s2 = this.colors;
    switch (t2) {
      case 0:
        this.s[2].color = s2.text, this.setSvg(this.c[3], "fill", s2.back, 0), this.setSvg(this.c[3], "fill", s2.button, 1), this.setSvg(this.c[3], "stroke", s2.back, 2), this.setSvg(this.c[3], "stroke", s2.back, 3), this.setSvg(this.c[3], "stroke", s2.text, 4);
        break;
      case 1:
        this.s[2].color = s2.textSelect, this.setSvg(this.c[3], "fill", s2.backoff, 0), this.setSvg(this.c[3], "fill", s2.overoff, 1), this.setSvg(this.c[3], "stroke", s2.backoff, 2), this.setSvg(this.c[3], "stroke", s2.backoff, 3), this.setSvg(this.c[3], "stroke", s2.textSelect, 4);
    }
    return this.cmode = t2, true;
  }
  update(t2) {
    this.c[2].textContent = this.value, this.updateSVG(), t2 && this.send();
  }
  updateSVG() {
    1 == this.model && (this.setSvg(this.c[3], "y1", this.pos.y, 2), this.setSvg(this.c[3], "y2", this.pos.y, 2), this.setSvg(this.c[3], "x1", this.pos.x, 3), this.setSvg(this.c[3], "x2", this.pos.x, 3)), this.setSvg(this.c[3], "cx", this.pos.x, 4), this.setSvg(this.c[3], "cy", this.pos.y, 4);
  }
  setPos(t2) {
    this.pos.set(t2[0] + 128, t2[1] + 128);
    let s2 = 1 / this.maxPos;
    this.value[0] = (t2[0] * s2 * this.range).toFixed(this.precision), this.value[1] = (t2[1] * s2 * this.range).toFixed(this.precision);
  }
  setValue(t2, s2 = false) {
    void 0 === t2 && (t2 = this.value), this.value[0] = 1 * Math.min(this.max, Math.max(this.min, t2[0])).toFixed(this.precision), this.value[1] = 1 * Math.min(this.max, Math.max(this.min, t2[1])).toFixed(this.precision), this.pos.set(this.value[0] / this.range * this.maxPos + 128, this.value[1] / this.range * this.maxPos + 128), this.update(s2);
  }
};
var T = function() {
  let t2, s2, e2 = arguments, h2 = false, o2 = null;
  "string" == typeof e2[0] ? (t2 = e2[0], s2 = e2[1] || {}) : "object" == typeof e2[0] && (h2 = true, void 0 === e2[2] && [].push.call(e2, {}), t2 = e2[2].type ? e2[2].type : O(e2[0][e2[1]], e2[2]), s2 = e2[2], s2.name = e2[1], "list" !== t2 || s2.list ? s2.value = e2[0][e2[1]] : s2.list = e2[0][e2[1]]);
  let n2 = t2.toLowerCase();
  switch ("group" === n2 && (s2.add = T), n2) {
    case "bool":
    case "boolean":
      o2 = new l(s2);
      break;
    case "button":
      o2 = new a(s2);
      break;
    case "circular":
      o2 = new c(s2);
      break;
    case "color":
      o2 = new d(s2);
      break;
    case "fps":
      o2 = new u(s2);
      break;
    case "graph":
      o2 = new p(s2);
      break;
    case "group":
      o2 = new g(s2);
      break;
    case "joystick":
      o2 = new x(s2);
      break;
    case "knob":
      o2 = new v(s2);
      break;
    case "list":
      o2 = new b(s2);
      break;
    case "numeric":
    case "number":
      o2 = new f(s2);
      break;
    case "slide":
      o2 = new w(s2);
      break;
    case "textInput":
    case "string":
      o2 = new y(s2);
      break;
    case "title":
    case "text":
      o2 = new k(s2);
      break;
    case "select":
      o2 = new S(s2);
      break;
    case "bitmap":
      o2 = new I(s2);
      break;
    case "selector":
      o2 = new C(s2);
      break;
    case "empty":
    case "space":
      o2 = new m(s2);
      break;
    case "item":
      o2 = new M(s2);
      break;
    case "grid":
      o2 = new L(s2);
      break;
    case "pad2d":
    case "pad":
      o2 = new z(s2);
  }
  if (null !== o2)
    return i.needResize = true, h2 && o2.setReferency(e2[0], e2[1]), o2;
};
var O = function(t2, s2) {
  let i2 = "slide";
  return "boolean" == typeof t2 ? i2 = "bool" : "string" == typeof t2 ? i2 = "#" === t2.substring(0, 1) ? "color" : "string" : "number" == typeof t2 ? i2 = s2.ctype ? "color" : "slide" : "array" == typeof t2 && t2 instanceof Array ? "number" == typeof t2[0] ? i2 = "number" : "string" == typeof t2[0] && (i2 = "list") : "object" == typeof t2 && t2 instanceof Object && (i2 = void 0 !== t2.x ? "number" : "list"), i2;
};
var D = class {
  constructor(t2 = {}) {
    this.isGui = true, this.name = "gui", this.canvas = null, this.screen = null, this.plane = t2.plane || null, t2.config && (t2.colors = t2.config), t2.colors ? this.setConfig(t2.colors) : this.colors = h.defineColor(t2), this.css = h.cloneCss(), this.isReset = true, this.tmpAdd = null, this.isCanvas = t2.isCanvas || false, this.isCanvasOnly = false, this.callback = void 0 === t2.callback ? null : t2.callback, this.forceHeight = t2.maxHeight || 0, this.lockHeight = t2.lockHeight || false, this.isItemMode = void 0 !== t2.itemMode && t2.itemMode, this.cn = "", this.size = h.size, void 0 !== t2.p && (this.size.p = t2.p), void 0 !== t2.w && (this.size.w = t2.w), void 0 !== t2.h && (this.size.h = t2.h), void 0 !== t2.s && (this.size.s = t2.s), this.size.h = this.size.h < 11 ? 11 : this.size.h, this.local = new n().neg(), this.zone = { x: 0, y: 0, w: this.size.w, h: 0 }, this.mouse = new n().neg(), this.h = 0, this.sw = 0, this.margin = this.colors.sy, this.marginDiv = h.isDivid(this.margin), this.isWithClose = void 0 === t2.close || t2.close, this.bh = this.isWithClose ? this.size.h : 0, this.autoResize = void 0 === t2.autoResize || t2.autoResize, this.isCenter = t2.center || false, this.cssGui = void 0 !== t2.css ? t2.css : this.isCenter ? "" : "right:10px;", this.isOpen = void 0 === t2.open || t2.open, this.isDown = false, this.isScroll = false, this.uis = [], this.current = -1, this.proto = null, this.isEmpty = true, this.decal = 0, this.ratio = 1, this.oy = 0, this.isNewTarget = false;
    let s2 = this.colors;
    this.content = h.dom("div", this.css.basic + " width:0px; height:auto; top:0px; background:" + s2.content + "; " + this.cssGui), this.innerContent = h.dom("div", this.css.basic + "width:100%; top:0; left:0; height:auto; overflow:hidden;"), this.content.appendChild(this.innerContent), this.useFlex = true;
    let e2 = this.useFlex ? "display:flex; flex-flow: row wrap;" : "";
    this.inner = h.dom("div", this.css.basic + e2 + "width:100%; left:0; "), this.innerContent.appendChild(this.inner), this.scrollBG = h.dom("div", this.css.basic + "right:0; top:0; width:" + (this.size.s - 1) + "px; height:10px; display:none; background:" + s2.background + ";"), this.content.appendChild(this.scrollBG), this.scroll = h.dom("div", this.css.basic + "background:" + s2.button + "; right:2px; top:0; width:" + (this.size.s - 4) + "px; height:10px;"), this.scrollBG.appendChild(this.scroll), this.bottomText = t2.bottomText || ["open", "close"];
    let o2 = s2.radius;
    this.bottom = h.dom("div", this.css.txt + "width:100%; top:auto; bottom:0; left:0; border-bottom-right-radius:" + o2 + "px; border-bottom-left-radius:" + o2 + "px; justify-content:center; height:" + this.bh + "px; line-height:" + (this.bh - 5) + "px; color:" + s2.text + ";"), this.content.appendChild(this.bottom), this.bottom.textContent = this.isOpen ? this.bottomText[1] : this.bottomText[0], this.bottom.style.background = s2.background, this.parent = void 0 !== t2.parent ? t2.parent : null, this.parent = void 0 !== t2.target ? t2.target : this.parent, null !== this.parent || this.isCanvas || (this.parent = document.body), null !== this.parent && this.parent.appendChild(this.content), this.isCanvas && null === this.parent && (this.isCanvasOnly = true), this.isCanvasOnly ? (this.content.style.left = "0px", this.content.style.right = "auto", t2.transition = 0) : this.content.style.pointerEvents = "auto", this.transition = void 0 !== t2.transition ? t2.transition : h.transition, this.transition && setTimeout(this.addTransition.bind(this), 1e3), this.setWidth(), this.isCanvas && this.makeCanvas(), i.add(this);
  }
  setTop(t2, s2) {
    this.content.style.top = t2 + "px", void 0 !== s2 && (this.forceHeight = s2), this.calc(), i.needReZone = true;
  }
  addTransition() {
    this.transition && !this.isCanvas && (this.innerContent.style.transition = "height " + this.transition + "s ease-out", this.content.style.transition = "height " + this.transition + "s ease-out", this.bottom.style.transition = "top " + this.transition + "s ease-out");
    let t2 = this.uis.length;
    for (; t2--; )
      this.uis[t2].addTransition();
  }
  onDraw() {
  }
  makeCanvas() {
    this.canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.canvas.width = this.zone.w, this.canvas.height = this.forceHeight ? this.forceHeight : this.zone.h;
  }
  draw(t2) {
    if (null === this.canvas)
      return;
    let s2 = this.zone.w, e2 = this.forceHeight ? this.forceHeight : this.zone.h;
    i.toCanvas(this, s2, e2, t2);
  }
  getDom() {
    return this.content;
  }
  noMouse() {
    this.mouse.neg();
  }
  setMouse(t2, s2 = true) {
    s2 ? this.mouse.set(Math.round(t2.x * this.canvas.width), this.canvas.height - Math.round(t2.y * this.canvas.height)) : this.mouse.set(Math.round(t2.x * this.canvas.width), Math.round(t2.y * this.canvas.height));
  }
  setConfig(t2) {
    h.setText(), this.colors = h.defineColor(t2);
  }
  setColors(t2) {
    for (let s2 in t2)
      this.colors[s2] && (this.colors[s2] = t2[s2]);
  }
  setText(t2, s2, i2, e2) {
    h.setText(t2, s2, i2, e2);
  }
  hide(t2) {
    this.content.style.visibility = t2 ? "hidden" : "visible";
  }
  display(t2 = false) {
    this.content.style.visibility = t2 ? "visible" : "hidden";
  }
  onChange(t2) {
    return this.callback = t2 || null, this;
  }
  mode(t2) {
    let s2 = false, e2 = this.colors;
    if (t2 !== this.cn) {
      switch (this.cn = t2, t2) {
        case "def":
          i.cursor(), this.scroll.style.background = e2.button, this.bottom.style.background = e2.background, this.bottom.style.color = e2.text;
          break;
        case "scrollOver":
          i.cursor("ns-resize"), this.scroll.style.background = e2.select;
          break;
        case "scrollDown":
          this.scroll.style.background = e2.select;
          break;
        case "bottomOver":
          i.cursor("pointer"), this.bottom.style.background = e2.backgroundOver, this.bottom.style.color = e2.textOver;
      }
      s2 = true;
    }
    return s2;
  }
  clearTarget() {
    return -1 !== this.current && (this.proto.s && (this.proto.uiout(), this.proto.reset()), this.proto = null, this.current = -1, i.cursor(), true);
  }
  testZone(t2) {
    let s2 = this.local;
    if (-1 === s2.x && -1 === s2.y)
      return "";
    this.isReset = false;
    let i2 = "", e2 = this.isScroll ? this.zone.w - this.size.s : this.zone.w;
    return i2 = s2.y > this.zone.h - this.bh && s2.y < this.zone.h ? "bottom" : s2.x > e2 ? "scroll" : "content", i2;
  }
  handleEvent(t2) {
    let s2 = t2.type, e2 = false, h2 = false, o2 = this.testZone(t2);
    if ("mouseup" === s2 && this.isDown && (this.isDown = false), "mousedown" !== s2 || this.isDown || (this.isDown = true), this.isDown && this.isNewTarget && (i.clearInput(), this.isNewTarget = false), o2) {
      switch (o2) {
        case "content":
          t2.clientY = this.isScroll ? t2.clientY + this.decal : t2.clientY, i.isMobile && "mousedown" === s2 && this.getNext(t2, e2), this.proto && (h2 = this.proto.handleEvent(t2)), "mousemove" === s2 && (e2 = this.mode("def")), "wheel" === s2 && !h2 && this.isScroll && (e2 = this.onWheel(t2)), i.lock || this.getNext(t2, e2);
          break;
        case "bottom":
          this.clearTarget(), "mousemove" === s2 && (e2 = this.mode("bottomOver")), "mousedown" === s2 && (this.isOpen = !this.isOpen, this.bottom.textContent = this.isOpen ? this.bottomText[1] : this.bottomText[0], this.calc(), this.mode("def"), e2 = true);
          break;
        case "scroll":
          this.clearTarget(), "mousemove" === s2 && (e2 = this.mode("scrollOver")), "mousedown" === s2 && (e2 = this.mode("scrollDown")), "wheel" === s2 && (e2 = this.onWheel(t2)), this.isDown && this.update(t2.clientY - this.zone.y - 0.5 * this.sh);
      }
      this.isDown && (e2 = true), h2 && (e2 = true), "keyup" === s2 && (e2 = true), "keydown" === s2 && (e2 = true), e2 && this.draw();
    }
  }
  getNext(t2, s2) {
    let e2 = i.findTarget(this.uis, t2);
    e2 !== this.current && (this.clearTarget(), this.current = e2, this.isNewTarget = true), -1 !== e2 && (this.proto = this.uis[this.current], this.proto.uiover());
  }
  onWheel(t2) {
    return this.oy += 20 * t2.delta, this.update(this.oy), true;
  }
  reset(t2) {
    if (this.isReset)
      return;
    this.mouse.neg(), this.isDown = false;
    let s2 = this.mode("def"), i2 = this.clearTarget();
    (s2 || i2) && this.draw(true), this.isReset = true;
  }
  add() {
    let t2 = arguments, s2 = false;
    "object" == typeof t2[1] ? (t2[1].isUI = true, t2[1].main = this, s2 = !!t2[1].ontop && t2[1].ontop) : "string" == typeof t2[1] && (void 0 === t2[2] ? [].push.call(t2, { isUI: true, main: this }) : (t2[2].isUI = true, t2[2].main = this, s2 = !!t2[2].ontop && t2[2].ontop));
    let i2 = T.apply(this, t2);
    if (null !== i2)
      return s2 ? this.uis.unshift(i2) : this.uis.push(i2), this.calc(), this.isEmpty = false, i2;
  }
  remove(t2) {
    t2.dispose && t2.dispose();
  }
  clearOne(t2) {
    let s2 = this.uis.indexOf(t2);
    -1 !== s2 && (this.inner.removeChild(this.uis[s2].c[0]), this.uis.splice(s2, 1), this.calc());
  }
  empty() {
    let t2, s2 = this.uis.length;
    for (; s2--; )
      t2 = this.uis.pop(), this.inner.removeChild(t2.c[0]), t2.dispose();
    this.uis = [], this.isEmpty = true, this.calc();
  }
  clear() {
    this.empty();
  }
  clear2() {
    setTimeout(this.empty.bind(this), 0);
  }
  dispose() {
    this.clear(), null !== this.parent && this.parent.removeChild(this.content), i.remove(this);
  }
  resetItem() {
    if (!this.isItemMode)
      return;
    let t2 = this.uis.length;
    for (; t2--; )
      this.uis[t2].selected();
  }
  setItem(t2) {
    if (!this.isItemMode)
      return;
    if (t2 = t2 || "", this.resetItem(), !t2)
      return void this.update(0);
    let s2 = this.uis.length;
    for (; s2--; )
      this.uis[s2].value === t2 && (this.uis[s2].selected(true), this.isScroll && this.update(s2 * (this.uis[s2].h + this.margin) * this.ratio));
  }
  upScroll(t2) {
    this.sw = t2 ? this.size.s : 0, this.oy = t2 ? this.oy : 0, this.scrollBG.style.display = t2 ? "block" : "none", t2 && (this.total = this.h, this.maxView = this.maxHeight, this.ratio = this.maxView / this.total, this.sh = this.maxView * this.ratio, this.range = this.maxView - this.sh, this.oy = h.clamp(this.oy, 0, this.range), this.scrollBG.style.height = this.maxView + "px", this.scroll.style.height = this.sh + "px"), this.setItemWidth(this.zone.w - this.sw), this.update(this.oy);
  }
  update(t2) {
    t2 = h.clamp(t2, 0, this.range), this.decal = Math.floor(t2 / this.ratio), this.inner.style.top = -this.decal + "px", this.scroll.style.top = Math.floor(t2) + "px", this.oy = t2;
  }
  calcUis() {
    return i.calcUis(this.uis, this.zone, this.zone.y);
  }
  calc() {
    clearTimeout(this.tmp), this.tmp = setTimeout(this.setHeight.bind(this), 10);
  }
  setHeight() {
    if (this.tmp && clearTimeout(this.tmp), this.zone.h = this.bh, this.isScroll = false, this.isOpen) {
      this.h = this.calcUis();
      let t2 = this.forceHeight ? this.forceHeight + this.zone.y : window.innerHeight;
      this.maxHeight = t2 - this.zone.y - this.bh, this.h - this.maxHeight > 1 ? (this.isScroll = true, this.zone.h = this.maxHeight + this.bh) : this.zone.h = this.h + this.bh;
    }
    this.upScroll(this.isScroll), this.innerContent.style.height = this.zone.h - this.bh + "px", this.content.style.height = this.zone.h + "px", this.bottom.style.top = this.zone.h - this.bh + "px", this.forceHeight && this.lockHeight && (this.content.style.height = this.forceHeight + "px"), this.isCanvas && this.draw(true);
  }
  rezone() {
    i.needReZone = true;
  }
  setWidth(t2) {
    t2 && (this.zone.w = t2), this.zone.w = Math.floor(this.zone.w), this.content.style.width = this.zone.w + "px", this.isCenter && (this.content.style.marginLeft = -Math.floor(0.5 * this.zone.w) + "px"), this.setItemWidth(this.zone.w - this.sw);
  }
  setItemWidth(t2) {
    let s2 = this.uis.length;
    for (; s2--; )
      this.uis[s2].setSize(t2), this.uis[s2].rSize();
  }
};
export {
  o as Files,
  D as Gui,
  t as REVISION,
  h as Tools,
  T as add
};
/*! Bundled license information:

uil/build/uil.module.js:
  (**
   * @license
   * Copyright 2010-2021 Uil.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=uil.js.map
